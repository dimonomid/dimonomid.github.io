<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>TNeo: Why reimplement TNKernel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-7163754-5', 'auto');
  ga('send', 'pageview');
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TNeo
   &#160;<span id="projectnumber">v1.07</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Why reimplement TNKernel </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#why_reimplement__problems_of_tnkernel">Essential problems of TNKernel</a></li>
<li class="level1"><a href="#why_reimplement__tnkernel_impl_details">Examples of poor implementation</a><ul><li class="level2"><a href="#why_reimplement__one_exit_point">One entry point, one exit point</a></li>
<li class="level2"><a href="#why_reimplement__dont_repeat_yourself">Don't repeat yourself</a></li>
<li class="level2"><a href="#why_reimplement__returning_macro">Macros that return from function</a></li>
<li class="level2"><a href="#why_reimplement__linked_lists">Code for doubly-linked lists</a></li>
</ul>
</li>
<li class="level1"><a href="#why_reimplement__bugs">Bugs of TNKernel 2.7</a></li>
</ul>
</div>
<div class="textblock"><p>Explanation of essential TNKernel problems as well as several examples of poor implementation.</p>
<h1><a class="anchor" id="why_reimplement__problems_of_tnkernel"></a>
Essential problems of TNKernel</h1>
<ul>
<li>The most essential problem is that TNKernel is a very hastily-written project. Several concepts are just poorly thought out, others are poorly implemented: there is a lot of code duplication and inconsistency;</li>
<li>It is untested: there are no unit tests for the kernel, this is not acceptable for the project like real-time kernel;</li>
</ul>
<p>As a result of the two above, the kernel is buggy. And even more, the kernel is really <b>hard to maintain</b> because of inconsistency, so when we add new features or change something, we are likely to add new bugs as well.</p>
<ul>
<li>It is unsupported. I've written to the Yuri Tiomkin about <a class="el" href="tnkernel_diff.html#tnkernel_diff_make_alig">troubles with MAKE_ALIG() macro</a> as well as about bugs in the kernel, my messages were just ignored;</li>
<li>Documentation is far from perfect and it lives separately of the project itself: latest kernel version at the moment is 2.7 (published at 2013), but latest documentation is for 2.3 (published at 2006).</li>
</ul>
<h1><a class="anchor" id="why_reimplement__tnkernel_impl_details"></a>
Examples of poor implementation</h1>
<h2><a class="anchor" id="why_reimplement__one_exit_point"></a>
One entry point, one exit point</h2>
<p>The most common example that happens across all TNKernel sources is code like the following:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> my_function(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="tn__oldsymbols_8h.html#a27bf94f93625fa36125c3fa3ae6b4041">tn_disable_interrupt</a>();</div>
<div class="line">   <span class="comment">//-- do something</span></div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span> (error()){</div>
<div class="line">      <span class="comment">//-- do something</span></div>
<div class="line"></div>
<div class="line">      <a class="code" href="tn__oldsymbols_8h.html#acc85567ca09ede9cf2d58717506def46">tn_enable_interrupt</a>();</div>
<div class="line">      <span class="keywordflow">return</span> ERROR;</div>
<div class="line">   }</div>
<div class="line">   <span class="comment">//-- do something</span></div>
<div class="line"></div>
<div class="line">   <a class="code" href="tn__oldsymbols_8h.html#acc85567ca09ede9cf2d58717506def46">tn_enable_interrupt</a>();</div>
<div class="line">   <span class="keywordflow">return</span> SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you have multiple <code>return</code> statements or, even more, if you have to perform some action before return (<code><a class="el" href="tn__oldsymbols_8h.html#acc85567ca09ede9cf2d58717506def46" title="old TNKernel name of TN_INT_RESTORE ">tn_enable_interrupt()</a></code> in the example above), it's great job for <code>goto</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> my_function(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">int</span> rc = SUCCESS;</div>
<div class="line">   <a class="code" href="tn__oldsymbols_8h.html#a27bf94f93625fa36125c3fa3ae6b4041">tn_disable_interrupt</a>();</div>
<div class="line">   <span class="comment">//-- do something</span></div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span> (error()){</div>
<div class="line">      <span class="comment">//-- do something</span></div>
<div class="line">      rc = ERROR;</div>
<div class="line">      <span class="keywordflow">goto</span> out;</div>
<div class="line">   }</div>
<div class="line">   <span class="comment">//-- do something</span></div>
<div class="line"></div>
<div class="line">out:</div>
<div class="line">   <a class="code" href="tn__oldsymbols_8h.html#acc85567ca09ede9cf2d58717506def46">tn_enable_interrupt</a>();</div>
<div class="line">   <span class="keywordflow">return</span> rc;</div>
<div class="line">}</div>
</div><!-- fragment --><p>I understand there are a lot of people that don't agree with me on this (mostly because they religiously believe that <code>goto</code> is unconditionally evil), but anyway I decided to explain it. And, let's go further:</p>
<p>While multiple <code>goto</code>-s to single label are better than multiple <code>return</code> statements, it becomes less useful as we get to something more complicated. Imagine we need to perform some checks <em>before</em> disabling interrupts, and perform some other checks <em>after</em> disabling them. Then, we have to create two labels, like that:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> my_function(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">int</span> rc = SUCCESS;</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span> (error1()){</div>
<div class="line">      rc = ERROR1;</div>
<div class="line">      <span class="keywordflow">goto</span> out;</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <a class="code" href="tn__oldsymbols_8h.html#a27bf94f93625fa36125c3fa3ae6b4041">tn_disable_interrupt</a>();</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span> (error2()){</div>
<div class="line">      rc = ERROR2;</div>
<div class="line">      <span class="keywordflow">goto</span> out_ei;</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span> (error3()){</div>
<div class="line">      rc = ERROR3;</div>
<div class="line">      <span class="keywordflow">goto</span> out_ei;</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="comment">//-- perform job</span></div>
<div class="line"></div>
<div class="line">out_ei:</div>
<div class="line">   <a class="code" href="tn__oldsymbols_8h.html#acc85567ca09ede9cf2d58717506def46">tn_enable_interrupt</a>();</div>
<div class="line"></div>
<div class="line">out:</div>
<div class="line">   <span class="keywordflow">return</span> rc;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For each error handling, we should specify the label explicitly, and it's easy to mix labels up, especially if we add some new case to check in the future. So, I believe this approach is a superior:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> my_function(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">int</span> rc = SUCCESS;</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span> (error1()){</div>
<div class="line">      rc = ERROR1;</div>
<div class="line">   } <span class="keywordflow">else</span> {</div>
<div class="line">      <a class="code" href="tn__oldsymbols_8h.html#a27bf94f93625fa36125c3fa3ae6b4041">tn_disable_interrupt</a>();</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (error2()){</div>
<div class="line">         rc = ERROR2;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error3()){</div>
<div class="line">         rc = ERROR3;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">         <span class="comment">//-- perform job</span></div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <a class="code" href="tn__oldsymbols_8h.html#acc85567ca09ede9cf2d58717506def46">tn_enable_interrupt</a>();</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">return</span> rc;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then, for each new error handling, we should just add new <code>else if</code> block, and there's no need to care where to go if error happened. Let the compiler do the branching job for you. More, this code looks more compact.</p>
<p>Needless to say, I already found such bug in original TNKernel 2.7 code. The function <code><a class="el" href="tn__oldsymbols_8h.html#a74b0cfd9bbf5a85f4e0d00a984f60f5e" title="old TNKernel name of tn_sys_tslice_set ">tn_sys_tslice_ticks()</a></code> looks as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="tn__oldsymbols_8h.html#a74b0cfd9bbf5a85f4e0d00a984f60f5e">tn_sys_tslice_ticks</a>(<span class="keywordtype">int</span> <a class="code" href="structTN__Task.html#a43c9c73249da8faa1177587786c40616">priority</a>,<span class="keywordtype">int</span> value)</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="tn__arch__example_8h.html#a58899c98640384b8a2cf7f9ba6f53a23">TN_INTSAVE_DATA</a></div>
<div class="line"></div>
<div class="line">   TN_CHECK_NON_INT_CONTEXT</div>
<div class="line"></div>
<div class="line">   <a class="code" href="tn__oldsymbols_8h.html#a27bf94f93625fa36125c3fa3ae6b4041">tn_disable_interrupt</a>();</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span>(priority &lt;= 0 || priority &gt;= <a class="code" href="tn__oldsymbols_8h.html#a63b4da81df067abd19fe86f5712a34e3">TN_NUM_PRIORITY</a>-1 ||</div>
<div class="line">                                value &lt; 0 || value &gt; <a class="code" href="tn__oldsymbols_8h.html#a7a8524d52a91ba1841e95f6d4f0dcd6b">MAX_TIME_SLICE</a>)</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="tn__oldsymbols_8h.html#a35ec519d54f884d84c5814f49f00a22b">TERR_WRONG_PARAM</a>;</div>
<div class="line"></div>
<div class="line">   tn_tslice_ticks[<a class="code" href="structTN__Task.html#a43c9c73249da8faa1177587786c40616">priority</a>] = value;</div>
<div class="line"></div>
<div class="line">   <a class="code" href="tn__oldsymbols_8h.html#acc85567ca09ede9cf2d58717506def46">tn_enable_interrupt</a>();</div>
<div class="line">   <span class="keywordflow">return</span> <a class="code" href="tn__oldsymbols_8h.html#a71970f860643e62fad7ec03076bdc1d8">TERR_NO_ERR</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you look closely, you can see that if wrong params were given, <code><a class="el" href="tn__oldsymbols_8h.html#a35ec519d54f884d84c5814f49f00a22b" title="old TNKernel name of TN_RC_WPARAM ">TERR_WRONG_PARAM</a></code> is returned, and <b>interrupts remain disabled</b>. If we follow the <em>one entry point, one exit point</em> rule, this bug is much less likely to happen.</p>
<h2><a class="anchor" id="why_reimplement__dont_repeat_yourself"></a>
Don't repeat yourself</h2>
<p>Original TNKernel 2.7 code has <b>a lot</b> of code duplication. So many similar things are done in several places just by copy-pasting the code.</p>
<ul>
<li>If we have similar functions (like, <code><a class="el" href="tn__dqueue_8h.html#a043dd3133a57489d7d10f53be6939957" title="Send the data element specified by the p_data to the data queue specified by the dque. ">tn_queue_send()</a></code>, <code><a class="el" href="tn__dqueue_8h.html#af60c61c12ed90f4bcc7d13ca4da8562b" title="The same as tn_queue_send() with zero timeout. ">tn_queue_send_polling()</a></code> and <code><a class="el" href="tn__dqueue_8h.html#ac059f15f07625ca25e4aac5790cce1ea" title="The same as tn_queue_send() with zero timeout, but for using in the ISR. ">tn_queue_isend_polling()</a></code>), the implementation is just copy-pasted, there's no effort to generalize things.</li>
<li>Mutexes have complicated algorithms for task priorities. It is implemented in inconsistent, messy manner, which leads to bugs (refer to <a class="el" href="why_reimplement.html#why_reimplement__bugs">Bugs of TNKernel 2.7</a>)</li>
<li><p class="startli">Transitions between task states are done, again, in inconsistent copy-pasting manner. When we need to move task from, say, <a class="el" href="tn__tasks_8h.html#a5e12e8a0ab280b515f44bf3fee1210a6a02783ac7808aeda318a6f506b7a276dc"><code>RUNNABLE</code></a> state to the <a class="el" href="tn__tasks_8h.html#a5e12e8a0ab280b515f44bf3fee1210a6aaa3dfaf2bb5992e0cef981618ce30d56"><code>WAIT</code></a> state, it's not enough to just clear one flag and set another one: we also need to remove it from whatever run queue the task is contained, probably find next task to run, then set reason of waiting, probably add to wait queue, set up timeout if specified, etc. In original TNKernel 2.7, there's no general mechanism to do this.</p>
<p class="startli">Meanwhile, the correct way is to create three functions for each state:</p><ul>
<li>to set the state;</li>
<li>to clear the state;</li>
<li>to test if the state active.</li>
</ul>
<p class="startli">And then, when we need to move task from one state to another, we typically should just call two functions: one for clearing current state, and one for settine a new one. It <b>is</b> consistent, and of course this approach is used in TNeo.</p>
</li>
</ul>
<p>As a result of the violation of the rule <em>Don't repeat yourself</em>, when we need to change something, we need to change it in several places. Needless to say, it is very error-prone practice, and of course there are bugs in original TNKernel because of that (refer to <a class="el" href="why_reimplement.html#why_reimplement__bugs">Bugs of TNKernel 2.7</a>).</p>
<h2><a class="anchor" id="why_reimplement__returning_macro"></a>
Macros that return from function</h2>
<p>TNKernel uses architecture-depended macros like <code>TN_CHECK_NON_INT_CONTEXT</code>. This macro checks the current context (task or ISR), and if it is ISR, it returns <code>TERR_WRONG_PARAM</code>.</p>
<p>It isn't obvious to the reader of the code, but things like returning from function <b>must</b> be as obvious as possible.</p>
<p>It is better to invent some function that tests current context, and return the value explicitly:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876">TN_RCode</a> my_function(<span class="keywordtype">void</span>)</div>
<div class="line">   enum <a class="code" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876">TN_RCode</a> rc = <a class="code" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876afb291924237186f5765865256c75e639">TN_RC_OK</a>;</div>
<div class="line"></div>
<div class="line">   <span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">   if (!<a class="code" href="tn__sys_8h.html#a77aab9748bbca8609e3daf6d18855a06">tn_is_task_context</a>()){</div>
<div class="line">      rc = <a class="code" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876a886368391507ae426bfdedc38284db9d">TN_RC_WCONTEXT</a>;</div>
<div class="line">      <span class="keywordflow">goto</span> out;</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">out:</div>
<div class="line">   <span class="keywordflow">return</span> rc</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="why_reimplement__linked_lists"></a>
Code for doubly-linked lists</h2>
<p>TNKernel uses doubly-linked lists heavily, which is very good. I must admit that I really like the way data is organized in TNKernel. But, unfortunately, code that manages data is far from perfect, as I already mentioned.</p>
<p>So, let's get to the lists. I won't paste all the macros here, just make some overview. If we have a list, it's very common task to iterate through it. Typical snippet in TNKernel looks like this:</p>
<div class="fragment"><div class="line"><a class="code" href="structTN__ListItem.html">CDLL_QUEUE</a> * curr_que;</div>
<div class="line"><a class="code" href="structTN__Mutex.html">TN_MUTEX</a> * tmp_mutex;</div>
<div class="line"></div>
<div class="line">curr_que = tn_curr_run_task-&gt;mutex_queue.<a class="code" href="structTN__ListItem.html#a66648d1a9069530836c3fd738b03ab96">next</a>;</div>
<div class="line"><span class="keywordflow">while</span>(curr_que != &amp;(tn_curr_run_task-&gt;mutex_queue))</div>
<div class="line">{</div>
<div class="line">   tmp_mutex = get_mutex_by_mutex_queque(curr_que);</div>
<div class="line"></div>
<div class="line">   <span class="comment">/* now, tmp_mutex points to the next object, so,</span></div>
<div class="line"><span class="comment">      we can do something useful with it */</span></div>
<div class="line"></div>
<div class="line">   curr_que = curr_que-&gt;<a class="code" href="structTN__ListItem.html#a66648d1a9069530836c3fd738b03ab96">next</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This code is neither easy to read nor elegant. It's much better to use special macro for that (actually, similar macros are used across the whole Linux kernel code) :</p>
<div class="fragment"><div class="line"><a class="code" href="structTN__Mutex.html">TN_MUTEX</a> * tmp_mutex;</div>
<div class="line"></div>
<div class="line">tn_list_for_each_entry(tmp_mutex, &amp;(tn_curr_run_task-&gt;mutex_queue), <a class="code" href="structTN__Task.html#ad4decd7355c95a5b60a6774c3ee19eb9">mutex_queue</a>){</div>
<div class="line">   <span class="comment">/* now, tmp_mutex points to the next object, so,</span></div>
<div class="line"><span class="comment">      we can do something useful with it */</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Much shorter and intuitive, isn't it? We even don't have to keep special <code>curr_que</code>.</p>
<h1><a class="anchor" id="why_reimplement__bugs"></a>
Bugs of TNKernel 2.7</h1>
<p>TNKernel 2.7 has several bugs, which are caught by detailed unit tests and fixed.</p>
<ul>
<li>We have two tasks: low-priority one <code>task_low</code> and high-priority one <code>task_high</code>. They use mutex <code>M1</code> with priority inheritance.<ul>
<li><code>task_low</code> locks <code>M1</code></li>
<li><code>task_high</code> tries to lock mutex <code>M1</code> and gets blocked -&gt; priority of <code>task_low</code> elevates to the priority of <code>task_high</code></li>
<li><code>task_high</code> stops waiting for mutex by timeout -&gt; priority of <code>task_low</code> remains elevated. The same happens if <code>task_high</code> is terminated by <code><a class="el" href="tn__tasks_8h.html#a8ae6615de7022a327bdcd4c37a0f5b90" title="This function is similar to tn_task_exit() but it terminates any task other than currently running on...">tn_task_terminate()</a></code>.</li>
</ul>
</li>
<li>We have three tasks: two low-priority tasks <code>task_low1</code> and <code>task_low2</code>, and high-priority one <code>task_high</code>. They use mutex <code>M1</code> with priority inheritance.<ul>
<li><code>task_low1</code> locks <code>M1</code></li>
<li><code>task_low2</code> tries to lock <code>M1</code> and gets blocked</li>
<li><code>task_high</code> tries to lock <code>M1</code> and gets blocked -&gt; priority if <code>task_low1</code> is elevated</li>
<li><code>task_low1</code> unlocks <code>M1</code> -&gt;<ul>
<li>priority of <code>task_low1</code> returns to base value</li>
<li><code>task_low2</code> locks <code>M1</code> because it's the next task in the mutex queue</li>
<li>now, priority of <code>task_low2</code> should be elevated, but it doesn't happen. Priority inversion is in effect.</li>
</ul>
</li>
</ul>
</li>
<li><code><a class="el" href="tn__mutex_8h.html#a9c935ae470f1d36f8d88c254a4d513e4" title="Destruct mutex. ">tn_mutex_delete()</a></code> : if mutex is not locked, <code><a class="el" href="tn__oldsymbols_8h.html#acc6afb7d5fab73e262e8cb4f9fd06ac4" title="old TNKernel name of TN_RC_ILLEGAL_USE ">TERR_ILUSE</a></code> is returned. Of course, task should be able to delete non-locked mutex;</li>
<li>If task that waits for mutex is in <a class="el" href="tn__tasks_8h.html#a5e12e8a0ab280b515f44bf3fee1210a6ad010070ccc16a5c706c286baf2e3ee2a"><code>WAIT+SUSPEND</code></a> state, and mutex is deleted, <code><a class="el" href="tn__oldsymbols_8h.html#a71970f860643e62fad7ec03076bdc1d8" title="old TNKernel name of TN_RC_OK ">TERR_NO_ERR</a></code> is returned after returning from <a class="el" href="tn__tasks_8h.html#a5e12e8a0ab280b515f44bf3fee1210a6adcf21b28920038f38cccc50fda12ba58"><code>SUSPEND</code></a> state, instead of <code><a class="el" href="tn__oldsymbols_8h.html#ae6a83c118d209d8702c3fc40d58ea18f" title="old TNKernel name of TN_RC_DELETED ">TERR_DLT</a></code>. The same for queue deletion, semaphore deletion, event deletion.</li>
<li><code><a class="el" href="tn__oldsymbols_8h.html#a74b0cfd9bbf5a85f4e0d00a984f60f5e" title="old TNKernel name of tn_sys_tslice_set ">tn_sys_tslice_ticks()</a></code> : if wrong params are given, <code><a class="el" href="tn__oldsymbols_8h.html#a35ec519d54f884d84c5814f49f00a22b" title="old TNKernel name of TN_RC_WPARAM ">TERR_WRONG_PARAM</a></code> is returned and interrupts remain disabled.</li>
<li><code><a class="el" href="tn__dqueue_8h.html#ab47ed49af7dffc5a71eaabd25422d0e4" title="Receive the data element from the data queue specified by the dque and place it into the address spec...">tn_queue_receive()</a></code> and <code><a class="el" href="tn__fmem_8h.html#a2ecd094041dbd0e92d61b852b7952444" title="Get memory block from the pool. ">tn_fmem_get()</a></code> : if <code>timeout</code> is in effect, then <code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876a5b4d73fde6b5d1c9579c02e6aafce1fb" title="Timeout (consult TN_TickCnt for details). ">TN_RC_TIMEOUT</a></code> is returned, but user-provided pointer is altered anyway (some garbage data is written there)</li>
<li>Probably not a "bug", but an issue in the data queue: actual capacity of the buffer is less by 1 than user has specified and allocated</li>
<li>Event: if <code>TN_EVENT_ATTR_CLR</code> flag is set, and the task that is waiting for event is suspended, this flag <code>TN_EVENT_ATTR_CLR</code> is ignored (pattern is not reset). I can't say this bug is "fixed" because TNeo has <a class="el" href="tnkernel_diff.html#tnkernel_diff_event">event groups instead of events</a>, and there is no <code>TN_EVENT_ATTR_CLR</code> flag.</li>
</ul>
<p>Bugs with mutexes are the direct result of the inconsistency and copy-pasting the code, as well as lack of unit tests. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 17 2015 01:32:25 for TNeo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
