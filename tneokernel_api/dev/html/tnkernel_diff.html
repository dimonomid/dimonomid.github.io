<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>TNeo: Differences from TNKernel API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-7163754-5', 'auto');
  ga('send', 'pageview');
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TNeo
   &#160;<span id="projectnumber">BETA v1.08-11-g97e5a6d</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Differences from TNKernel API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tnkernel_diff_api">Incompatible API changes</a><ul><li class="level2"><a href="#tnkernel_diff_api_sys_start">System startup</a></li>
<li class="level2"><a href="#tnkernel_diff_task_create">Task creation API</a></li>
<li class="level2"><a href="#tnkernel_diff_wakeup_count">Task wakeup count, activate count, suspend count</a></li>
<li class="level2"><a href="#tnkernel_diff_fmem">Fixed memory pool: non-aligned address or block size</a></li>
<li class="level2"><a href="#tnkernel_diff_task_retval">Task service return values cleaned</a></li>
<li class="level2"><a href="#tnkernel_diff_release_wait">Force task releasing from wait</a></li>
<li class="level2"><a href="#tnkernel_diff_task_sleep">Return code of tn_task_sleep()</a></li>
<li class="level2"><a href="#tnkernel_diff_event">Events API is changed almost completely</a></li>
<li class="level2"><a href="#tnkernel_diff_zero_timeout">Zero timeout given to system functions</a></li>
</ul>
</li>
<li class="level1"><a href="#tnkernel_new_features">New features</a></li>
<li class="level1"><a href="#tnkernel_new_api">Compatible API changes</a><ul><li class="level2"><a href="#tnkernel_diff_make_alig">Macro MAKE_ALIG()</a></li>
<li class="level2"><a href="#tnkernel_new_api__convenience_macros_stack">Convenience macros for stack arrays definition</a></li>
<li class="level2"><a href="#tnkernel_new_api__convenience_macros_fmem">Convenience macros for fixed memory block pool buffers definition</a></li>
<li class="level2"><a href="#tnkernel_diff_api_rename">Things renamed</a></li>
<li class="level2"><a href="#tnkernel_diff_api_rename_sem">We should wait for semaphore, not acquire it</a></li>
</ul>
</li>
<li class="level1"><a href="#tnkernel_diff_other">Changes that do not affect API directly</a><ul><li class="level2"><a href="#tnkernel_diff_timer_task">No timer task</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>If you have experience of using TNKernel, you really want to read this.</p>
<h1><a class="anchor" id="tnkernel_diff_api"></a>
Incompatible API changes</h1>
<h2><a class="anchor" id="tnkernel_diff_api_sys_start"></a>
System startup</h2>
<p>Original TNKernel code designed to be built together with main project only, there's no way to build as a separate library: at least, arrays for idle and timer task stacks are allocated statically, so size of them is defined at tnkernel compile time.</p>
<p>It's much better if we could pass these things to tnkernel at runtime, so, <code><a class="el" href="tn__sys_8h.html#a62ab25d9d8ca01c02d368968f19e49bf" title="Initial TNeo system start function, never returns. ">tn_sys_start()</a></code> now takes pointers to stack arrays and their sizes. Refer to <a class="el" href="quick_guide.html#starting_the_kernel">Starting the kernel</a> section for the details.</p>
<h2><a class="anchor" id="tnkernel_diff_task_create"></a>
Task creation API</h2>
<p>In original TNKernel, one should give bottom address of the task stack to <code><a class="el" href="tn__tasks_8h.html#a548d5adda09d1b4e393b5df0e9e1a7a5" title="Construct task and probably start it (depends on options, see below). ">tn_task_create()</a></code>, like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MY_STACK_SIZE   0x100</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_stack[ MY_STACK_SIZE ];</div><div class="line"></div><div class="line"><a class="code" href="tn__tasks_8h.html#a548d5adda09d1b4e393b5df0e9e1a7a5">tn_task_create</a>(<span class="comment">/* ... several arguments omitted ... */</span></div><div class="line">               &amp;(my_stack[ MY_STACK_SIZE - 1]),</div><div class="line">               <span class="comment">/* ... several arguments omitted ... */</span>);</div></div><!-- fragment --><p>Alex Borisov implemented it more conveniently in his port: one should give just array address, like this: </p><div class="fragment"><div class="line"><a class="code" href="tn__tasks_8h.html#a548d5adda09d1b4e393b5df0e9e1a7a5">tn_task_create</a>(<span class="comment">/* ... several arguments omitted ... */</span></div><div class="line">               my_stack,</div><div class="line">               <span class="comment">/* ... several arguments omitted ... */</span>);</div></div><!-- fragment --><p>TNeo uses the second way (i.e. the way used in the port by Alex Borisov), and it does so independently of the architecture being used.</p>
<h2><a class="anchor" id="tnkernel_diff_wakeup_count"></a>
Task wakeup count, activate count, suspend count</h2>
<p>In original TNKernel, requesting non-sleeping task to wake up is quite legal and causes next call to <code><a class="el" href="tn__tasks_8h.html#ae768a72ca0efde5767796cc1770bd45e" title="Put current task to sleep for at most timeout ticks. ">tn_task_sleep()</a></code> to not sleep. The same is with suspending/resuming tasks.</p>
<p>So, if you call <code><a class="el" href="tn__tasks_8h.html#abb88bc8b1cec6b82e7b6e2e90d0e155a" title="Wake up task from sleep. ">tn_task_wakeup()</a></code> on non-sleeping task first time, <code><a class="el" href="tn__oldsymbols_8h.html#a71970f860643e62fad7ec03076bdc1d8" title="old TNKernel name of TN_RC_OK ">TERR_NO_ERR</a></code> is returned. If you call it second time, before target task called <code><a class="el" href="tn__tasks_8h.html#ae768a72ca0efde5767796cc1770bd45e" title="Put current task to sleep for at most timeout ticks. ">tn_task_sleep()</a></code>, <code><a class="el" href="tn__oldsymbols_8h.html#abfe40d04917509ecd3a98c38878df5ff" title="old TNKernel name of TN_RC_OVERFLOW ">TERR_OVERFLOW</a></code> is returned.</p>
<p>All of this seems to me as a complete dirty hack, it probably might be used as a workaround to avoid race condition problems, or as a hacky replacement for semaphore.</p>
<p>It just encourages programmer to go with hacky approach, instead of creating straightforward semaphore and provide proper synchronization.</p>
<p>In TNeo these "features" are removed, and if you try to wake up non-sleeping task, or try to resume non-suspended task, <code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876a7b6d93374f52ba4b2fc01b38b783aa4c" title="Wrong task state error: requested operation requires different task state. ">TN_RC_WSTATE</a></code> is returned.</p>
<p>By the way, <code>suspend_count</code> is present in <code>TCB</code> structure, but is never used, so, it is just removed. And comments for <code>wakeup_count</code>, <code>activate_count</code>, <code>suspend_count</code> suggested that these fields are used for statistics, which is clearly not true.</p>
<h2><a class="anchor" id="tnkernel_diff_fmem"></a>
Fixed memory pool: non-aligned address or block size</h2>
<p>In original TNKernel it's illegal to pass <code>block_size</code> that is less than <code>sizeof(int)</code>. But, it is legal to pass some value that isn't multiple of <code>sizeof(int)</code>: in this case, <code>block_size</code> is silently rounded up, and therefore <code>block_cnt</code> is silently decremented to fit as many blocks of newly calculated <code>block_size</code> as possible. If resulting <code>block_cnt</code> is at least 2, it is assumed that everything is fine and we can go on.</p>
<p>Why I don't like it: firstly, silent behavior like this is generally bad practice that leads to hard-to-catch bugs. Secondly, it is inconsistency again: why is it legal for <code>block_size</code> not to be multiple of <code>sizeof(int)</code>, but it is illegal for it to be less than <code>sizeof(int)</code>? After all, the latter is the partucular case of the former.</p>
<p>So, TNeo returns <code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876a89909a6426b477a38496a1be67590e68" title="This code is returned by most of the kernel functions when wrong params were given to function...">TN_RC_WPARAM</a></code> in these cases. User must provide <code>start_addr</code> and <code>block_size</code> that are properly aligned.</p>
<p>TNeo also provides convenience macro <code><a class="el" href="tn__fmem_8h.html#ab45e9c2ad4a64345214f9a912bf76fc3" title="Convenience macro for the definition of buffer for memory pool. ">TN_FMEM_BUF_DEF()</a></code> for buffer definition, so, as a generic rule, it is good practice to define buffers for memory pool like this:</p>
<div class="fragment"><div class="line"><span class="comment">//-- number of blocks in the pool</span></div><div class="line"><span class="preprocessor">#define MY_MEMORY_BUF_SIZE    8</span></div><div class="line"></div><div class="line"><span class="comment">//-- type for memory block</span></div><div class="line"><span class="keyword">struct </span>MyMemoryItem {</div><div class="line">   <span class="comment">// ... arbitrary fields ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">//-- define buffer for memory pool</span></div><div class="line"><a class="code" href="tn__fmem_8h.html#ab45e9c2ad4a64345214f9a912bf76fc3">TN_FMEM_BUF_DEF</a>(my_fmem_buf, <span class="keyword">struct</span> MyMemoryItem, MY_MEMORY_BUF_SIZE);</div><div class="line"></div><div class="line"><span class="comment">//-- define memory pool structure</span></div><div class="line"><span class="keyword">struct </span><a class="code" href="structTN__FMem.html">TN_FMem</a> my_fmem;</div></div><!-- fragment --><p>And then, construct your <code>my_fmem</code> as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876">TN_RCode</a> rc;</div><div class="line">rc = <a class="code" href="tn__fmem_8h.html#a56d47d4a1b6453d959336448a0ce96ac">tn_fmem_create</a>( &amp;my_fmem,</div><div class="line">                     my_fmem_buf,</div><div class="line">                     <a class="code" href="tn__common_8h.html#a3f48380e8a624edc643319a81192d88e">TN_MAKE_ALIG_SIZE</a>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> MyMemoryItem)),</div><div class="line">                     MY_MEMORY_BUF_SIZE );</div><div class="line"><span class="keywordflow">if</span> (rc != <a class="code" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876afb291924237186f5765865256c75e639">TN_RC_OK</a>){</div><div class="line">   <span class="comment">//-- handle error</span></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="tnkernel_diff_task_retval"></a>
Task service return values cleaned</h2>
<p>In original TNKernel, <code><a class="el" href="tn__oldsymbols_8h.html#ad591ae7c53bbb81247492ea1d34a70b6" title="old TNKernel name of TN_RC_WCONTEXT ">TERR_WCONTEXT</a></code> is returned in the following cases:</p>
<ul>
<li>call to <code><a class="el" href="tn__tasks_8h.html#a8ae6615de7022a327bdcd4c37a0f5b90" title="This function is similar to tn_task_exit() but it terminates any task other than currently running on...">tn_task_terminate()</a></code> for already terminated task;</li>
<li>call to <code><a class="el" href="tn__tasks_8h.html#adbc4dbbd4a57b73642b76550a0c7c83f" title="This function deletes the task specified by the task. ">tn_task_delete()</a></code> for non-terminated task;</li>
<li>call to <code><a class="el" href="tn__tasks_8h.html#a2ddad9d6dc0e611a7f09c878463aea41" title="Set new priority for task. ">tn_task_change_priority()</a></code> for terminated task;</li>
<li>call to <code><a class="el" href="tn__tasks_8h.html#abb88bc8b1cec6b82e7b6e2e90d0e155a" title="Wake up task from sleep. ">tn_task_wakeup()</a></code>/<code><a class="el" href="tn__tasks_8h.html#a94e6a0312013e53cf08bcf871e6f4172" title="The same as tn_task_wakeup() but for using in the ISR. ">tn_task_iwakeup()</a></code> for terminated task;</li>
<li>call to <code><a class="el" href="tn__tasks_8h.html#ae90ecdbd7d87d050c2c98ec775e6efc7" title="Release task from WAIT state, independently of the reason of waiting. ">tn_task_release_wait()</a></code>/<code><a class="el" href="tn__tasks_8h.html#aee0ef296af18733f64269386adf8a2d7" title="The same as tn_task_release_wait() but for using in the ISR. ">tn_task_irelease_wait()</a></code> for terminated task.</li>
</ul>
<p>The actual error is, of course, wrong state, not wrong context; so, TNeo returns <code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876a7b6d93374f52ba4b2fc01b38b783aa4c" title="Wrong task state error: requested operation requires different task state. ">TN_RC_WSTATE</a></code> in these cases.</p>
<h2><a class="anchor" id="tnkernel_diff_release_wait"></a>
Force task releasing from wait</h2>
<p>In original TNKernel, a call to <code><a class="el" href="tn__tasks_8h.html#ae90ecdbd7d87d050c2c98ec775e6efc7" title="Release task from WAIT state, independently of the reason of waiting. ">tn_task_release_wait()</a></code> / <code><a class="el" href="tn__tasks_8h.html#aee0ef296af18733f64269386adf8a2d7" title="The same as tn_task_release_wait() but for using in the ISR. ">tn_task_irelease_wait()</a></code> causes waiting task to wake up, regardless of wait reason, and <code><a class="el" href="tn__oldsymbols_8h.html#a71970f860643e62fad7ec03076bdc1d8" title="old TNKernel name of TN_RC_OK ">TERR_NO_ERR</a></code> is returned as a wait result. Actually I believe it is bad idea to ever use <code><a class="el" href="tn__tasks_8h.html#ae90ecdbd7d87d050c2c98ec775e6efc7" title="Release task from WAIT state, independently of the reason of waiting. ">tn_task_release_wait()</a></code>, but if we have this service, error code surely should be distinguishable from normal wait completion, so, new code is added: <code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876ae5cbacb0fb01805c9003046c08bf4356" title="Task was released from waiting forcibly because some other task called tn_task_release_wait() ...">TN_RC_FORCED</a></code>, and it is returned when task wakes up because of <code><a class="el" href="tn__tasks_8h.html#ae90ecdbd7d87d050c2c98ec775e6efc7" title="Release task from WAIT state, independently of the reason of waiting. ">tn_task_release_wait()</a></code> call.</p>
<h2><a class="anchor" id="tnkernel_diff_task_sleep"></a>
Return code of tn_task_sleep()</h2>
<p>In original TNKernel, <code><a class="el" href="tn__tasks_8h.html#ae768a72ca0efde5767796cc1770bd45e" title="Put current task to sleep for at most timeout ticks. ">tn_task_sleep()</a></code> always returns <code><a class="el" href="tn__oldsymbols_8h.html#a71970f860643e62fad7ec03076bdc1d8" title="old TNKernel name of TN_RC_OK ">TERR_NO_ERR</a></code>, independently of what actually happened. In TNeo, there are three possible return codes:</p>
<ul>
<li><code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876a5b4d73fde6b5d1c9579c02e6aafce1fb" title="Timeout (consult TN_TickCnt for details). ">TN_RC_TIMEOUT</a></code> if timeout is actually in effect;</li>
<li><code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876afb291924237186f5765865256c75e639" title="Successful operation. ">TN_RC_OK</a></code> if task was woken up by some other task with <code><a class="el" href="tn__tasks_8h.html#abb88bc8b1cec6b82e7b6e2e90d0e155a" title="Wake up task from sleep. ">tn_task_wakeup()</a></code>;</li>
<li><code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876ae5cbacb0fb01805c9003046c08bf4356" title="Task was released from waiting forcibly because some other task called tn_task_release_wait() ...">TN_RC_FORCED</a></code> if task was woken up forcibly by some other task with <code><a class="el" href="tn__tasks_8h.html#ae90ecdbd7d87d050c2c98ec775e6efc7" title="Release task from WAIT state, independently of the reason of waiting. ">tn_task_release_wait()</a></code>;</li>
</ul>
<h2><a class="anchor" id="tnkernel_diff_event"></a>
Events API is changed almost completely</h2>
<p>Note: for old TNKernel projects, there is a compatibility mode, see <code><a class="el" href="tn__cfg__default_8h.html#ac61d5f6a716cdcab205a2c8afbde4242" title="Whether the old TNKernel events API compatibility mode is active. ">TN_OLD_EVENT_API</a></code>.</p>
<p>In original TNKernel, I always found events API somewhat confusing. Why is this object named "event", but there are many flags inside, so that they can actually represent many events?</p>
<p>Meanwhile, attributes like <code>TN_EVENT_ATTR_SINGLE</code>, <code>TN_EVENT_ATTR_CLR</code> imply that "event" object is really just a single event, since it makes no sense to clear just <b>all</b> event bits when some particular event happened.</p>
<p>After all, when we call <code><a class="el" href="tn__oldsymbols_8h.html#aee4d9866fcfb8b9b6a96066b288150dc">tn_event_clear(&amp;my_event_obj, flags)</a></code>, we might expect that <code>flags</code> argument actually specifies flags to clear. But in fact, we must invert it, to make it work: <code>~flags</code>. This is really confusing.</p>
<p>In TNeo, there is no such <em>event</em> object. Instead, there is object <em>events group</em>. Attributes like <code>...SINGLE</code>, <code>...MULTI</code>, <code>...CLR</code> are removed, since they make no sense for events group. Instead, you may set the flag <code><a class="el" href="tn__eventgrp_8h.html#a9d42ee61ae8da342f1cd6440b7e54bbdaf45098235d31f72a2b09e30792686573" title="When a task successfully ends waiting for event bit(s), these bits get cleared atomically and automat...">TN_EVENTGRP_WMODE_AUTOCLR</a></code> when task is going to wait for some event bit(s), and then these event bit(s) will be atomically cleared automatically when task successfully finishes waiting for these bits.</p>
<p>TNeo also offers a very useful feature: connecting an event group to other kernel objects. Refer to the section <a class="el" href="tn__eventgrp_8h.html#eventgrp_connect">Connecting an event group to other system objects</a>.</p>
<p>For detailed API reference, refer to the <code><a class="el" href="tn__eventgrp_8h.html" title="Event group. ">tn_eventgrp.h</a></code>.</p>
<h2><a class="anchor" id="tnkernel_diff_zero_timeout"></a>
Zero timeout given to system functions</h2>
<p>In original TNKernel, system functions refused to perform job and returned <code><a class="el" href="tn__oldsymbols_8h.html#a35ec519d54f884d84c5814f49f00a22b" title="old TNKernel name of TN_RC_WPARAM ">TERR_WRONG_PARAM</a></code> if <code>timeout</code> is 0, but it is actually neither convenient nor intuitive: it is much better if the function behaves just like <code>...polling()</code> version of the function. All TNeo system functions allows timeout to be zero: in this case, function doesn't wait.</p>
<h1><a class="anchor" id="tnkernel_new_features"></a>
New features</h1>
<p>Well, I'm tired of maintaining this additional list of features, so I just say that there is a lot of new features: timers, event group connection, stack overflow check, recursive mutexes, mutex deadlock detection, profiler, dynamic tick, etc.</p>
<p>Refer to the generic <a class="el" href="features.html">feature list</a>.</p>
<h1><a class="anchor" id="tnkernel_new_api"></a>
Compatible API changes</h1>
<h2><a class="anchor" id="tnkernel_diff_make_alig"></a>
Macro MAKE_ALIG()</h2>
<p>There is a terrible mess with <code><a class="el" href="tn__oldsymbols_8h.html#aa42d2e6b5b7ff37bd485803fa2cb70a8" title="old TNKernel name of TN_MAKE_ALIG macro ">MAKE_ALIG()</a></code> macro: TNKernel docs specify that the argument of it should be the size to align, but almost all ports, including original one, defined it so that it takes type, not size.</p>
<p>But the port by AlexB implemented it differently (i.e. accordingly to the docs) : it takes size as an argument.</p>
<p>When I was moving from the port by AlexB to another one, do you have any idea how much time it took me to figure out why do I have rare weird bug? :)</p>
<p>By the way, additional strange thing: why doesn't this macro have any prefix like <code>TN_</code>?</p>
<p>TNeo provides macro <code><a class="el" href="tn__common_8h.html#a3f48380e8a624edc643319a81192d88e" title="Macro for making a number a multiple of sizeof(TN_UWord), should be used with fixed memory block pool...">TN_MAKE_ALIG_SIZE()</a></code> whose argument is <b>size</b>, so, its usage is as follows: <code><a class="el" href="tn__common_8h.html#a3f48380e8a624edc643319a81192d88e" title="Macro for making a number a multiple of sizeof(TN_UWord), should be used with fixed memory block pool...">TN_MAKE_ALIG_SIZE(sizeof(struct MyStruct))</a></code>. This macro is preferred.</p>
<p>But for compatibility with messy <code><a class="el" href="tn__oldsymbols_8h.html#aa42d2e6b5b7ff37bd485803fa2cb70a8" title="old TNKernel name of TN_MAKE_ALIG macro ">MAKE_ALIG()</a></code> from original TNKernel, there is an option <code><a class="el" href="tn__cfg__default_8h.html#a2a1148efc6a74131cc83ee50cbc386cd" title="API option for MAKE_ALIG() macro. ">TN_API_MAKE_ALIG_ARG</a></code> with two possible values;</p>
<ul>
<li><code><a class="el" href="tn__cfg__dispatch_8h.html#a4972bf0cbc72e51a7463cf7d786d2b64" title="In this case, you should use macro like this: TN_MAKE_ALIG(sizeof(struct my_struct)). ">TN_API_MAKE_ALIG_ARG__SIZE</a></code> - default value, use macro like this: <code><a class="el" href="tn__oldsymbols_8h.html#aa42d2e6b5b7ff37bd485803fa2cb70a8" title="old TNKernel name of TN_MAKE_ALIG macro ">MAKE_ALIG(sizeof(struct my_struct))</a></code>, like in the port by Alex.</li>
<li><code><a class="el" href="tn__cfg__dispatch_8h.html#a04321413cf21754a05682b298df0493d" title="In this case, you should use macro like this: TN_MAKE_ALIG(struct my_struct). ">TN_API_MAKE_ALIG_ARG__TYPE</a></code> - use macro like this: <code><a class="el" href="tn__oldsymbols_8h.html#aa42d2e6b5b7ff37bd485803fa2cb70a8" title="old TNKernel name of TN_MAKE_ALIG macro ">MAKE_ALIG(struct my_struct)</a></code>, like in any other port.</li>
</ul>
<p>By the way, I wrote to the author of TNKernel (Yuri Tiomkin) about this mess, but he didn't answer anything. It's a pity of course, but we have what we have.</p>
<h2><a class="anchor" id="tnkernel_new_api__convenience_macros_stack"></a>
Convenience macros for stack arrays definition</h2>
<p>You can still use "manual" definition of stack arrays, like that:</p>
<div class="fragment"><div class="line"><a class="code" href="tn__arch__example_8h.html#ae245dddb19cd7c12b7038a62d576fafa">TN_ARCH_STK_ATTR_BEFORE</a></div><div class="line"><a class="code" href="tn__arch__example_8h.html#ab80cba0fe9ffcd9011d53dfeb9e39bf4">TN_UWord</a> my_task_stack[ MY_TASK_STACK_SIZE ]</div><div class="line"><a class="code" href="tn__arch__example_8h.html#ab082613959b539182b8b47bc87d18d6a">TN_ARCH_STK_ATTR_AFTER</a>;</div></div><!-- fragment --><p>Although it is recommended to use convenience macro for that: <code><a class="el" href="tn__sys_8h.html#ad61af0f0e9ab96bdf1ac1bf1e03e3c75" title="Convenience macro for the definition of stack array. ">TN_STACK_ARR_DEF()</a></code>. See <code><a class="el" href="tn__tasks_8h.html#a548d5adda09d1b4e393b5df0e9e1a7a5" title="Construct task and probably start it (depends on options, see below). ">tn_task_create()</a></code> for the usage example.</p>
<h2><a class="anchor" id="tnkernel_new_api__convenience_macros_fmem"></a>
Convenience macros for fixed memory block pool buffers definition</h2>
<p>Similarly to the previous section, you can still use "manual" definition of the buffer for fixed memory block pool, it is recommended to use convenience macro for that: <code><a class="el" href="tn__fmem_8h.html#ab45e9c2ad4a64345214f9a912bf76fc3" title="Convenience macro for the definition of buffer for memory pool. ">TN_FMEM_BUF_DEF()</a></code>. See <code><a class="el" href="tn__fmem_8h.html#a56d47d4a1b6453d959336448a0ce96ac" title="Construct fixed memory blocks pool. ">tn_fmem_create()</a></code> for usage example.</p>
<h2><a class="anchor" id="tnkernel_diff_api_rename"></a>
Things renamed</h2>
<p>There is a lot of inconsistency with naming stuff in original TNKernel:</p>
<ul>
<li>Why do we have <code><a class="el" href="tn__dqueue_8h.html#af60c61c12ed90f4bcc7d13ca4da8562b" title="The same as tn_queue_send() with zero timeout. ">tn_queue_send_polling()</a></code> / <code><a class="el" href="tn__dqueue_8h.html#ac059f15f07625ca25e4aac5790cce1ea" title="The same as tn_queue_send() with zero timeout, but for using in the ISR. ">tn_queue_isend_polling()</a></code> (notice the <code>i</code> letter before the verb, not before <code>polling</code>), but <code><a class="el" href="tn__fmem_8h.html#affea42ad41734fadfe8170b4234ca567" title="The same as tn_fmem_get() with zero timeout. ">tn_fmem_get_polling()</a></code> / <code><a class="el" href="tn__oldsymbols_8h.html#a4293c359514306825a9007f071b2ad3f" title="old TNKernel name of tn_fmem_iget_polling ">tn_fmem_get_ipolling()</a></code> (notice the <code>i</code> letter before <code>polling</code>)?</li>
<li>All the system service names follow the naming scheme <code>tn_&lt;noun&gt;_&lt;verb&gt;[_&lt;adjustment&gt;]()</code>, but the <code><a class="el" href="tn__oldsymbols_8h.html#a566625be14a6eed4a3574e3d31e776fc" title="old TNKernel name of tn_sys_start ">tn_start_system()</a></code> is special, for some strange reason. To make it consistent, it should be named <code>tn_system_start()</code> or <code><a class="el" href="tn__sys_8h.html#a62ab25d9d8ca01c02d368968f19e49bf" title="Initial TNeo system start function, never returns. ">tn_sys_start()</a></code>;</li>
<li>A lot of macros don't have <code>TN_</code> prefix;</li>
<li>etc</li>
</ul>
<p>So, a lot of things (functions, macros, etc) has renamed. Old names are also available through <code><a class="el" href="tn__oldsymbols_8h.html" title="Compatibility layer for old projects that use old TNKernel names; usage of them in new projects is di...">tn_oldsymbols.h</a></code>, which is included automatically if <code><a class="el" href="tn__cfg__default_8h.html#ae9854c723c6a823c9126aa8390977d39" title="Whether old TNKernel names (definitions, functions, etc) should be available. ">TN_OLD_TNKERNEL_NAMES</a></code> option is non-zero.</p>
<h2><a class="anchor" id="tnkernel_diff_api_rename_sem"></a>
We should wait for semaphore, not acquire it</h2>
<p>One of the renamings deserves special mentioning: <code><a class="el" href="tn__oldsymbols_8h.html#abdc5c428590ff525cdb566da613015ce" title="old name of tn_sem_wait ">tn_sem_acquire()</a></code> and friends are renamed to <code><a class="el" href="tn__sem_8h.html#acfed2a27719c87638d2eb6edfdeea150" title="Wait for the semaphore. ">tn_sem_wait()</a></code> and friends. That's because names acquire/release are actually misleading for the semaphore: semaphore is a <em>signaling mechanism</em>, and <b>not</b> the locking mechanism.</p>
<p>Actually, there's a lot of confusion about usage of mutexes/semaphores, so it's quite recommended to read small article by Michael Barr: <a href="http://goo.gl/YprPBW">Mutexes and Semaphores Demystified</a>.</p>
<p>Old names (<code><a class="el" href="tn__oldsymbols_8h.html#abdc5c428590ff525cdb566da613015ce" title="old name of tn_sem_wait ">tn_sem_acquire()</a></code> and friends) are still available through <code><a class="el" href="tn__oldsymbols_8h.html" title="Compatibility layer for old projects that use old TNKernel names; usage of them in new projects is di...">tn_oldsymbols.h</a></code>.</p>
<h1><a class="anchor" id="tnkernel_diff_other"></a>
Changes that do not affect API directly</h1>
<h2><a class="anchor" id="tnkernel_diff_timer_task"></a>
No timer task</h2>
<p>Yes, timer task's job is important: it manages <code>tn_wait_timeout_list</code>, i.e. it wakes up tasks whose timeout is expired. But it's actually better to do it right in <code><a class="el" href="tn__sys_8h.html#aa44d297639e0520420890ef2bb7e2c1c" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> that is called from timer ISR, because presence of the special task provides significant overhead. Look at what happens when timer interrupt is fired (assume we don't use shadow register set for that, which is almost always the case):</p>
<p>(measurements were made at PIC32 port)</p>
<ul>
<li>Current context (23 words) is saved to the interrupt stack;</li>
<li>ISR called: particularly, <code><a class="el" href="tn__sys_8h.html#aa44d297639e0520420890ef2bb7e2c1c" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> is called;</li>
<li><code><a class="el" href="tn__sys_8h.html#aa44d297639e0520420890ef2bb7e2c1c" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> disables interrupts, manages round-robin (if needed), then it wakes up <code>tn_timer_task</code>, sets <code>tn_next_task_to_run</code>, and enables interrupts back;</li>
<li><code><a class="el" href="tn__sys_8h.html#aa44d297639e0520420890ef2bb7e2c1c" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> finishes, so ISR macro checks that <code>tn_next_task_to_run</code> is different from <code>tn_curr_run_task</code>, and sets <code>CS0</code> interrupt bit, so that context should be switched as soon as possible;</li>
<li>Context (23 words) gets restored to whatever task we interrupted;</li>
<li><code>CS0</code> ISR is immediately called, so full context (32 words) gets saved on task's stack, and context of <code>tn_timer_task</code> is restored;</li>
<li><code>tn_timer_task</code> disables interrupts, performs its not so big job (manages <code>tn_wait_timeout_list</code>), puts itself to wait, enables interrupts and pends context switching again;</li>
<li><code>CS0</code> ISR is immediately called, so full context of <code>tn_timer_task</code> gets saved in its stack, and then, after all, context of my own interrupted task gets restored and my task continues to run.</li>
</ul>
<p>I've measured with MPLABX's stopwatch how much time it takes: with just three tasks (idle task, timer task, my own task with priority 6), i.e. without any sleeping tasks, all this routine takes <b>682 cycles</b>. So I tried to get rid of <code>tn_timer_task</code> and perform its job right in the <code><a class="el" href="tn__sys_8h.html#aa44d297639e0520420890ef2bb7e2c1c" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code>.</p>
<p>Previously, application callback was called from timer task; since it is removed now, startup routine has changed, refer to <a class="el" href="quick_guide.html#starting_the_kernel">Starting the kernel</a> for details.</p>
<p>Now, the following steps are performed when timer interrupt is fired:</p>
<ul>
<li>Current context (23 words) is saved to the interrupt stack;</li>
<li>ISR called: particularly, <code><a class="el" href="tn__sys_8h.html#aa44d297639e0520420890ef2bb7e2c1c" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> is called;</li>
<li><code><a class="el" href="tn__sys_8h.html#aa44d297639e0520420890ef2bb7e2c1c" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> disables interrupts, manages round-robin (if needed), manages <code>tn_wait_timeout_list</code>, and enables interrupts back;</li>
<li><code><a class="el" href="tn__sys_8h.html#aa44d297639e0520420890ef2bb7e2c1c" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> finishes, ISR macro checks that <code>tn_next_task_to_run</code> is the same as <code>tn_curr_run_task</code></li>
<li>Context (23 words) gets restored to whatever task we interrupted;</li>
</ul>
<p>That's all. It takes <b>251 cycles</b>: 2.7 times less.</p>
<p>So, we need to make sure that interrupt stack size is enough for this (not big) job. As a result, RAM is saved (since you don't need to allocate stack for timer task) and things work much faster. Win-win. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 18 2017 22:06:49 for TNeo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
