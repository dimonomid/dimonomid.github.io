<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>TNeo: Architecture-specific details</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-7163754-5', 'auto');
  ga('send', 'pageview');
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TNeo
   &#160;<span id="projectnumber">BETA v1.08-11-g97e5a6d</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Architecture-specific details </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#pic32_details">PIC32 port details</a><ul><li class="level2"><a href="#pic32_context_switch">Context switch</a></li>
<li class="level2"><a href="#pic32_interrupts">Interrupts</a></li>
<li class="level2"><a href="#pic32_building">Building</a></li>
</ul>
</li>
<li class="level1"><a href="#pic24_details">PIC24/dsPIC port details</a><ul><li class="level2"><a href="#pic24_context_switch">Context switch</a></li>
<li class="level2"><a href="#pic24_interrupts">Interrupts</a></li>
<li class="level2"><a href="#pic24_bfa">Atomic access to the structure bit field</a></li>
<li class="level2"><a href="#pic24_building">Building</a></li>
</ul>
</li>
<li class="level1"><a href="#cortex_m_details">Cortex-M0/M0+/M3/M4/M4F port details</a><ul><li class="level2"><a href="#cortex_m_context_switch">Context switch</a></li>
<li class="level2"><a href="#cortex_m_interrupts">Interrupts</a></li>
<li class="level2"><a href="#cortex_m_building">Building</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Architecture-specific details</p>
<h1><a class="anchor" id="pic32_details"></a>
PIC32 port details</h1>
<h2><a class="anchor" id="pic32_context_switch"></a>
Context switch</h2>
<p>The context switch is implemented using the core software 0 interrupt (<code>CS0</code>), which is configured by the kernel to the lowest priority (1). This interrupt is handled completely by the kernel, application should never touch it.</p>
<p>The interrupt priority level 1 should not be configured to use shadow register sets.</p>
<p>Multi-vectored interrupt mode should be enabled.</p>
<dl class="section attention"><dt>Attention</dt><dd>if tneo is built as a separate library (which is typically the case), then the file <code>src/arch/pic32/tn_arch_pic32_int_vec1.S</code> must be included in the main project itself, in order to dispatch vector1 (core software interrupt 0) correctly. Do note that if we include this file in the TNeo library project, it doesn't work for vector, unfortunately.</dd>
<dd>
If you forgot to include this file, you got an error on the link step, like this: <div class="fragment"><div class="line">undefined reference to `_you_should_add_file___tn_arch_pic32_int_vec1_S___to_the_project<span class="stringliteral">&#39;</span></div></div><!-- fragment --> Which is much more informative than if you just get to <code>_DefaultInterrupt</code> when it's time to switch context.</dd></dl>
<h2><a class="anchor" id="pic32_interrupts"></a>
Interrupts</h2>
<p>For generic information about interrupts in TNeo, refer to the page <a class="el" href="interrupts.html">Interrupts</a>.</p>
<p>PIC32 port has <em>system interrupts</em> only, there are no <em>user interrupts</em>.</p>
<p>PIC32 port supports nested interrupts. The kernel provides C-language macros for calling C-language interrupt service routines, which can use either MIPS32 or MIPS16e mode. Both software and shadow register interrupt context saving is supported. Usage is as follows:</p>
<div class="fragment"><div class="line"><span class="comment">/* Timer 1 interrupt handler using software interrupt context saving */</span></div><div class="line"><a class="code" href="tn__arch__pic32_8h.html#a02d853d8d573f928fb8da65ef0c2bc8e">tn_p32_soft_isr</a>(_TIMER_1_VECTOR)</div><div class="line">{</div><div class="line">   <span class="comment">/* here is your ISR code, including clearing of interrupt flag, and so on */</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* High-priority UART interrupt handler using shadow register set */</span></div><div class="line"><a class="code" href="tn__arch__pic32_8h.html#a523bb667617e6bb6f68a8f85855030a5">tn_p32_srs_isr</a>(_UART_1_VECTOR)</div><div class="line">{</div><div class="line">   <span class="comment">/* here is your ISR code, including clearing of interrupt flag, and so on */</span></div><div class="line">}</div></div><!-- fragment --><p>In spite of the fact that the kernel provides separate stack for interrupt, this isn't a mandatory on PIC32: you're able to define your ISR in a standard way, making it use stask of interrupted task and work a bit faster. Like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> __ISR(_TIMER_1_VECTOR) timer_1_isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">   <span class="comment">/* here is your ISR code, including clearing of interrupt flag, and so on */</span></div><div class="line">}</div></div><!-- fragment --><p>There is always a tradeoff. There are <b>no additional constraints</b> on ISR defined without kernel-provided macro: in either ISR, you can call the same set of kernel services.</p>
<p>When you make a decision on whether particular ISR should use separate stack, consider the following:</p>
<ul>
<li>When ISR is defined in a standard way, and no function is called from that ISR, only necessary registers are saved on stack. If you have such an ISR (that doesn't call any function), and this ISR should work very fast, consider using standard way instead of kernel-provided macro.</li>
<li>When ISR is defined in a standard way, but it calls any function and doesn't use shadow register set, compiler saves (almost) full context <b>on the task's stack</b>, because it doesn't know which registers are used inside the function. In this case, it usually makes more sense to use kernel-provided macro (see below).</li>
<li>Kernel-provided interrupt macros switch stack pointer between interrupt stack and task stack automatically, it takes additional time: e.g. on PIC32 it's about 20 cycles.</li>
<li>Kernel-provided interrupt macro that doesn't use shadow register set always saves (almost) full context <b>on the interrupt stack</b>, independently of whether any function is called from an ISR.</li>
<li>Kernel-provided interrupt macro that uses shadow register set saves a little amount of registers <b>on the interrupt stack</b>.</li>
</ul>
<h2><a class="anchor" id="pic32_building"></a>
Building</h2>
<p>For generic information on building TNeo, refer to the page <a class="el" href="building.html">Building TNeo</a>.</p>
<p>MPLABX project for PIC32 port resides in the <code>lib_project/pic32/tneo_pic32.X</code> directory. This is a <em>library project</em> in terms of MPLABX, so if you use MPLABX you can easily add it to your application project by right-clicking <code>Libraries -&gt; Add Library Project ...</code>. Alternatively, of course you can just build it and use resulting <code>tneo_pic32.X.a</code> file in whatever way you like.</p>
<p>If you want to build TNeo manually, refer to the section <a class="el" href="building.html#building_generic__manual">Building manually</a> for generic notes about it, and there is a couple of arch-dependent sources you need to add to the project:</p>
<ul>
<li><code>src/arch/pic32/tn_arch_pic32.c</code></li>
<li><code>src/arch/pic32/tn_arch_pic32mx_xc32.S</code></li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>There is one more file: <code>tn_arch_pic32_int_vec1.S</code>, which should be included <b>in your application project</b> to make things work. It is needed to dispatch vector1 (Core Software Interrupt 0) correctly.</dd></dl>
<h1><a class="anchor" id="pic24_details"></a>
PIC24/dsPIC port details</h1>
<h2><a class="anchor" id="pic24_context_switch"></a>
Context switch</h2>
<p>The context switch is implemented using the external interrupt 0 (<code>INT0</code>). It is handled completely by the kernel, application should never touch it.</p>
<h2><a class="anchor" id="pic24_interrupts"></a>
Interrupts</h2>
<p>For generic information about interrupts in TNeo, refer to the page <a class="el" href="interrupts.html">Interrupts</a>.</p>
<p>PIC24/dsPIC TNeo port supports nested interrupts. It allows to specify the range of <em>system interrupt priorities</em>. Refer to the subsection <a class="el" href="interrupts.html#interrupt_types">Interrupt types</a> for details on what is <em>system interrupt</em>.</p>
<p>System interrupts use separate interrupt stack instead of the task's stack. This approach saves a lot of RAM.</p>
<p>The range is specified by just a single number: <code><a class="el" href="tn__cfg__default_8h.html#a4feb7eb34fc2f175167b7496b63c398a" title="Maximum system interrupt priority. ">TN_P24_SYS_IPL</a></code>, which represents maximum <em>system interrupt priority</em>. Here is a list of available priorities and their characteristics:</p>
<ul>
<li>priorities <code>[1 .. <a class="el" href="tn__cfg__default_8h.html#a4feb7eb34fc2f175167b7496b63c398a" title="Maximum system interrupt priority. ">TN_P24_SYS_IPL</a>]</code>:<ul>
<li>Kernel services <b>are</b> allowed to call;</li>
<li>The macro <code><a class="el" href="tn__arch__pic24_8h.html#a0b184d3c15066f5504144379d2624ff3" title="ISR wrapper macro for software context saving. ">tn_p24_soft_isr()</a></code> <b>must</b> be used.</li>
<li>Separate interrupt stack is used by ISR;</li>
<li>Interrupts of these priorities get disabled for short periods of time when modifying critical kernel data (for about 100 cycles or the like).</li>
</ul>
</li>
<li>priorities <code>[(<a class="el" href="tn__cfg__default_8h.html#a4feb7eb34fc2f175167b7496b63c398a" title="Maximum system interrupt priority. ">TN_P24_SYS_IPL</a> + 1) .. 6]</code>:<ul>
<li>Kernel services <b>are not</b> allowed to call;</li>
<li>The macro <code><a class="el" href="tn__arch__pic24_8h.html#a0b184d3c15066f5504144379d2624ff3" title="ISR wrapper macro for software context saving. ">tn_p24_soft_isr()</a></code> <b>must not</b> be used.</li>
<li>Task's stack is used by ISR;</li>
<li>Interrupts of these priorities are not disabled when modifying critical kernel data, but they are disabled for 4..8 cycles by <code>disi</code> instruction when entering/exiting system ISR: we need to safely modify <code>SP</code> and <code>SPLIM</code>.</li>
</ul>
</li>
<li>priority <code>7</code>:<ul>
<li>Kernel services <b>are not</b> allowed to call;</li>
<li>The macro <code><a class="el" href="tn__arch__pic24_8h.html#a0b184d3c15066f5504144379d2624ff3" title="ISR wrapper macro for software context saving. ">tn_p24_soft_isr()</a></code> <b>must not</b> be used.</li>
<li>Task's stack is used by ISR;</li>
<li>Interrupts of these priorities are never disabled by the kernel (note that <code>disi</code> instruction leaves interrupts of priority 7 enabled).</li>
</ul>
</li>
</ul>
<p>The kernel provides C-language macro for calling C-language <b>system</b> interrupt service routines.</p>
<p>Usage is as follows:</p>
<div class="fragment"><div class="line"><span class="comment">/* </span></div><div class="line"><span class="comment"> * Timer 1 interrupt handler using software interrupt context saving,  </span></div><div class="line"><span class="comment"> * PSV is handled automatically:</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="tn__arch__pic24_8h.html#a0b184d3c15066f5504144379d2624ff3">tn_p24_soft_isr</a>(_T1Interrupt, auto_psv)</div><div class="line">{</div><div class="line">   <span class="comment">//-- clear interrupt flag</span></div><div class="line">   IFS0bits.T1IF = 0;</div><div class="line"></div><div class="line">   <span class="comment">//-- do something useful</span></div><div class="line">}</div></div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>do <b>not</b> use this macro for non-system interrupt (that is, for interrupt of priority higher than <code><a class="el" href="tn__cfg__default_8h.html#a4feb7eb34fc2f175167b7496b63c398a" title="Maximum system interrupt priority. ">TN_P24_SYS_IPL</a></code>). Use standard way to define it. If <code><a class="el" href="tn__cfg__default_8h.html#a1f197294df3276fec431930545acafd5" title="Enables additional param checking for most of the system functions. ">TN_CHECK_PARAM</a></code> is on, kernel checks it: if you violate this rule, debugger will be halted by the kernel when entering ISR. In release build, CPU is just reset.</dd></dl>
<h2><a class="anchor" id="pic24_bfa"></a>
Atomic access to the structure bit field</h2>
<p>The problem with PIC24/dsPIC is that when we write something like:</p>
<div class="fragment"><div class="line">IPC0bits.INT0IP = 0x05;</div></div><!-- fragment --><p>We actually have read-modify-write sequence which can be interrupted, so that resulting data could be corrupted. PIC24/dsPIC port provides several macros that offer atomic access to the structure bit field.</p>
<p>The kernel would not probably provide that kind of functionality, but TNeo itself needs it, so, it is made public so that application can use it too.</p>
<p>Refer to the page <a class="el" href="tn__arch__pic24__bfa_8h.html">Atomic bit-field access macros</a> for details.</p>
<h2><a class="anchor" id="pic24_building"></a>
Building</h2>
<p>For generic information on building TNeo, refer to the page <a class="el" href="building.html">Building TNeo</a>.</p>
<p>MPLABX project for PIC24/dsPIC port resides in the <code>lib_project/pic24_dspic/tneo_pic24_dspic.X</code> directory. This is a <em>library project</em> in terms of MPLABX, so if you use MPLABX you can easily add it to your main project by right-clicking <code>Libraries -&gt; Add Library Project ...</code>.</p>
<p>Alternatively, of course you can just build it and use resulting <code>.a</code> file in whatever way you like.</p>
<dl class="section attention"><dt>Attention</dt><dd>there are two configurations of this project: <em>eds</em> and <em> no_eds</em>, for devices with and without extended data space, respectively. When you add library project to your application project, you should select correct configuration for your device; otherwise, you get "undefined reference" errors at linker step.</dd></dl>
<p>If you want to build TNeo manually, refer to the section <a class="el" href="building.html#building_generic__manual">Building manually</a> for generic notes about it, and additionally you should add arch-dependent sources: all <code>.c</code> and <code>.S</code> files from <code>src/arch/pic24_dspic</code></p>
<h1><a class="anchor" id="cortex_m_details"></a>
Cortex-M0/M0+/M3/M4/M4F port details</h1>
<h2><a class="anchor" id="cortex_m_context_switch"></a>
Context switch</h2>
<p>The context switch is implemented in a standard for Cortex-M CPUs way: the PendSV exception. SVC exception is used for <code><a class="el" href="tn__arch_8h.html#afd5f43f42f5645de164ba6d13d3a4bcf" title="Called whenever we need to switch context to new task, but don&#39;t save current context. ">_tn_arch_context_switch_now_nosave()</a></code>. These two exceptions are configured by the kernel to the lowest priority.</p>
<h2><a class="anchor" id="cortex_m_interrupts"></a>
Interrupts</h2>
<p>For generic information about interrupts in TNeo, refer to the page <a class="el" href="interrupts.html">Interrupts</a>.</p>
<p>Cortex-M port has <em>system interrupts</em> only, there are no <em>user interrupts</em>.</p>
<p>Interrupts use separate interrupt stack, i.e. MSP (Main Stack Pointer). Tasks use PSP (Process Stack Pointer).</p>
<p>There are no constraints on ISRs: no special macros for ISR definition, or whatever. This is because Cortex-M processors are designed with OS applications in mind, so a number of featureas are available to make OS implementation easier and make OS operations more efficient.</p>
<h2><a class="anchor" id="cortex_m_building"></a>
Building</h2>
<p>For generic information on building TNeo, refer to the page <a class="el" href="building.html">Building TNeo</a>.</p>
<p>There are many environments for building for Cortex-M CPUs (Keil, Eclipse, CooCox), all available projects reside in <code>lib_project/cortex_m</code> directory. They usually are pretty enough if you want to just build the kernel with non-default configuration.</p>
<p>If, however, you want to build it not using provided project, refer to the section <a class="el" href="building.html#building_generic__manual">Building manually</a> for generic notes about it, and additionally you should add arch-dependent sources: all <code>.c</code> and <code>.S</code> files from <code>src/arch/cortex_m</code>.</p>
<p>There are some additional tips depending on the build environment:</p>
<p><b>Keil 5, ARMCC compiler</b></p>
<p>To satisfy <a class="el" href="building.html#building_generic__manual">building requirements</a>, a couple of actions needed:</p>
<ul>
<li>C99 is off by default. In project options, C/C++ tab, check "C99 Mode" checkbox.</li>
<li>Assembler files (<code>.S</code>) aren't preprocessed by default, so, in project options, Asm tab, "Misc Controls" field, type the following: <code>--cpreproc</code></li>
</ul>
<p><b>Keil 5, GCC compiler</b></p>
<p>Unfortunately, when GCC toolchain is used from Keil uVision IDE, for <code>.S</code> files it calls <code>arm-none-eabi-as</code>, which does not call C preprocessor.</p>
<p>Instead, <code>arm-none-eabi-gcc</code> should be used, but unfortunately I was unable to make Keil uVision issue <code>arm-none-eabi-gcc</code> for <code>.S</code> files, the only way to use GCC toolchain in Keil uVision that I'm aware of is to preprocess the file manually, like that: </p><pre class="fragment">cpp -P -undef tn_arch_cortex_m.S                         \
      -D __GNUC__ -D __ARM_ARCH -D __ARM_ARCH_7M__       \
      -I ../.. -I ../../core                             \
      &gt; tn_arch_cortex_m3_gcc.s
</pre><p>(this example is for Cortex-M3, you may check the file <code>tn_arch_detect.h</code> to see what should you define instead of <code>__ARM_ARCH_7M__</code> for other cores)</p>
<p>And then, add the output file <code>tn_arch_cortex_m3_gcc.s</code> to the project instead of <code>tn_arch_cortex_m.S</code> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 18 2017 22:06:49 for TNeo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
