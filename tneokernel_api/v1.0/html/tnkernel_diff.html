<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>TNeoKernel: Differences from TNKernel API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-7163754-5', 'auto');
  ga('send', 'pageview');
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TNeoKernel
   &#160;<span id="projectnumber">v1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Differences from TNKernel API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tnkernel_diff_api">Incompatible API changes</a><ul><li class="level2"><a href="#tnkernel_diff_api_sys_start">System startup</a></li>
<li class="level2"><a href="#tnkernel_diff_task_create">Task creation API</a></li>
<li class="level2"><a href="#tnkernel_diff_wakeup_count">Task wakeup count, activate count, suspend count</a></li>
<li class="level2"><a href="#tnkernel_diff_fmem">Fixed memory pool: non-aligned address or block size</a></li>
<li class="level2"><a href="#tnkernel_diff_task_retval">Task service return values cleaned</a></li>
<li class="level2"><a href="#tnkernel_diff_release_wait">Force task releasing from wait</a></li>
<li class="level2"><a href="#tnkernel_diff_task_sleep">Return code of tn_task_sleep()</a></li>
<li class="level2"><a href="#tnkernel_diff_event">Events API is changed almost completely</a></li>
<li class="level2"><a href="#tnkernel_diff_zero_timeout">Zero timeout given to system functions</a></li>
</ul>
</li>
<li class="level1"><a href="#tnkernel_new_api">Compatible API changes</a><ul><li class="level2"><a href="#tnkernel_diff_make_alig">Macro MAKE_ALIG()</a></li>
<li class="level2"><a href="#tnkernel_diff_mutex_rec">Recursive mutexes</a></li>
<li class="level2"><a href="#tnkernel_new_api__convenience_macros_stack">Convenience macros for stack arrays definition</a></li>
<li class="level2"><a href="#tnkernel_new_api__convenience_macros_fmem">Convenience macros for fixed memory block pool buffers definition</a></li>
<li class="level2"><a href="#tnkernel_diff_api_rename">Things renamed</a></li>
</ul>
</li>
<li class="level1"><a href="#tnkernel_diff_other">Changes that do not affect API directly</a><ul><li class="level2"><a href="#tnkernel_diff_timer_task">No timer task</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>If you have experience of using TNKernel, you really want to read this.</p>
<h1><a class="anchor" id="tnkernel_diff_api"></a>
Incompatible API changes</h1>
<h2><a class="anchor" id="tnkernel_diff_api_sys_start"></a>
System startup</h2>
<p>Original TNKernel code designed to be built together with main project only, there's no way to build as a separate library: at least, arrays for idle and timer task stacks are allocated statically, so size of them is defined at tnkernel compile time.</p>
<p>It's much better if we could pass these things to tnkernel at runtime, so, <code><a class="el" href="tn__sys_8h.html#a62ab25d9d8ca01c02d368968f19e49bf" title="Initial TNeoKernel system start function, never returns. ">tn_sys_start()</a></code> now takes pointers to stack arrays and their sizes. Refer to <a class="el" href="quick_guide.html#starting_the_kernel">Starting the kernel</a> section for the details.</p>
<h2><a class="anchor" id="tnkernel_diff_task_create"></a>
Task creation API</h2>
<p>In original TNKernel, one should give bottom address of the task stack to <code><a class="el" href="tn__tasks_8h.html#a548d5adda09d1b4e393b5df0e9e1a7a5" title="Construct task and probably start it (depends on options, see below). ">tn_task_create()</a></code>, like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MY_STACK_SIZE   0x100</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_stack[ MY_STACK_SIZE ];</div>
<div class="line"></div>
<div class="line"><a class="code" href="tn__tasks_8h.html#a548d5adda09d1b4e393b5df0e9e1a7a5">tn_task_create</a>(<span class="comment">/* ... several arguments omitted ... */</span></div>
<div class="line">               &amp;(my_stack[ MY_STACK_SIZE - 1]),</div>
<div class="line">               <span class="comment">/* ... several arguments omitted ... */</span>);</div>
</div><!-- fragment --><p>Alex Borisov implemented it more conveniently in his port: one should give just array address, like this: </p><div class="fragment"><div class="line"><a class="code" href="tn__tasks_8h.html#a548d5adda09d1b4e393b5df0e9e1a7a5">tn_task_create</a>(<span class="comment">/* ... several arguments omitted ... */</span></div>
<div class="line">               my_stack,</div>
<div class="line">               <span class="comment">/* ... several arguments omitted ... */</span>);</div>
</div><!-- fragment --><p>TNeoKernel uses the second way (i.e. the way used in port by Alex Borisov), and it does so independently of architecture.</p>
<h2><a class="anchor" id="tnkernel_diff_wakeup_count"></a>
Task wakeup count, activate count, suspend count</h2>
<p>In original TNKernel, requesting non-sleeping task to wake up is quite legal and causes next call to <code><a class="el" href="tn__tasks_8h.html#ad3708ae3400f11b98747ad4a1cad88fa" title="Put current task to sleep for at most timeout ticks. ">tn_task_sleep()</a></code> to not sleep. The same is with suspending/resuming tasks.</p>
<p>So, if you call <code><a class="el" href="tn__tasks_8h.html#abb88bc8b1cec6b82e7b6e2e90d0e155a" title="Wake up task from sleep. ">tn_task_wakeup()</a></code> on non-sleeping task first time, <code><a class="el" href="tn__oldsymbols_8h.html#a71970f860643e62fad7ec03076bdc1d8" title="old TNKernel name of TN_RC_OK ">TERR_NO_ERR</a></code> is returned. If you call it second time, before target task called <code><a class="el" href="tn__tasks_8h.html#ad3708ae3400f11b98747ad4a1cad88fa" title="Put current task to sleep for at most timeout ticks. ">tn_task_sleep()</a></code>, <code><a class="el" href="tn__oldsymbols_8h.html#abfe40d04917509ecd3a98c38878df5ff" title="old TNKernel name of TN_RC_OVERFLOW ">TERR_OVERFLOW</a></code> is returned.</p>
<p>All of this seems to me as a complete dirty hack, it probably might be used as a workaround to avoid race condition problems, or as a hacky replacement for semaphore.</p>
<p>It just encourages programmer to go with hacky approach, instead of creating straightforward semaphore and provide proper synchronization.</p>
<p>In TNeoKernel these "features" are removed, and if you try to wake up non-sleeping task, or try to resume non-suspended task, <code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876a7b6d93374f52ba4b2fc01b38b783aa4c" title="Wrong task state error: requested operation requires different task state. ">TN_RC_WSTATE</a></code> is returned.</p>
<p>By the way, <code>suspend_count</code> is present in <code>TCB</code> structure, but is never used, so, it is just removed. And comments for <code>wakeup_count</code>, <code>activate_count</code>, <code>suspend_count</code> suggested that these fields are used for statistics, which is clearly not true.</p>
<h2><a class="anchor" id="tnkernel_diff_fmem"></a>
Fixed memory pool: non-aligned address or block size</h2>
<p>In original TNKernel it's illegal to pass <code>block_size</code> that is less than <code>sizeof(int)</code>. But, it is legal to pass some value that isn't multiple of <code>sizeof(int)</code>: in this case, <code>block_size</code> is silently rounded up, and therefore <code>block_cnt</code> is silently decremented to fit as many blocks of newly calculated <code>block_size</code> as possible. If resulting <code>block_cnt</code> is at least 2, it is assumed that everything is fine and we can go on.</p>
<p>Why I don't like it: firstly, silent behavior like this is generally bad practice that leads to hard-to-catch bugs. Secondly, it is inconsistency again: why is it legal for <code>block_size</code> not to be multiple of <code>sizeof(int)</code>, but it is illegal for it to be less than <code>sizeof(int)</code>? After all, the latter is the partucular case of the former.</p>
<p>So, TNeoKernel returns <code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876a89909a6426b477a38496a1be67590e68" title="This code is returned by most of the kernel functions when wrong params were given to function...">TN_RC_WPARAM</a></code> in these cases. User must provide <code>start_addr</code> and <code>block_size</code> that are properly aligned. As a generic rule, it is good practice to declare buffers for fmp like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MY_MEMORY_BUF_SIZE    8</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>MyMemoryItem {</div>
<div class="line">   <span class="comment">// ... arbitrary fields ...</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> my_fmp_buf[</div>
<div class="line">        MY_MEMORY_BUF_SIZE </div>
<div class="line">        (<a class="code" href="tn__common_8h.html#a3f48380e8a624edc643319a81192d88e">TN_MAKE_ALIG_SIZE</a>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> MyMemoryItem)) / <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>))</div>
<div class="line">      ];</div>
<div class="line"><span class="keyword">struct </span>TN_Fmp my_fmp;</div>
</div><!-- fragment --><p>And then, construct your <code>my_fmp</code> as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="tn__fmem_8h.html#a56d47d4a1b6453d959336448a0ce96ac">tn_fmem_create</a>( &amp;my_fmp,</div>
<div class="line">                my_fmp_buf,</div>
<div class="line">                <a class="code" href="tn__common_8h.html#a3f48380e8a624edc643319a81192d88e">TN_MAKE_ALIG_SIZE</a>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> MyMemoryItem)),</div>
<div class="line">                MY_MEMORY_BUF_SIZE );</div>
</div><!-- fragment --><h2><a class="anchor" id="tnkernel_diff_task_retval"></a>
Task service return values cleaned</h2>
<p>In original TNKernel, <code><a class="el" href="tn__oldsymbols_8h.html#ad591ae7c53bbb81247492ea1d34a70b6" title="old TNKernel name of TN_RC_WCONTEXT ">TERR_WCONTEXT</a></code> is returned in the following cases:</p>
<ul>
<li>call to <code><a class="el" href="tn__tasks_8h.html#a8ae6615de7022a327bdcd4c37a0f5b90" title="This function is similar to tn_task_exit() but it terminates any task other than currently running on...">tn_task_terminate()</a></code> for already terminated task;</li>
<li>call to <code><a class="el" href="tn__tasks_8h.html#adbc4dbbd4a57b73642b76550a0c7c83f" title="This function deletes the task specified by the task. ">tn_task_delete()</a></code> for non-terminated task;</li>
<li>call to <code><a class="el" href="tn__tasks_8h.html#a2ddad9d6dc0e611a7f09c878463aea41" title="Set new priority for task. ">tn_task_change_priority()</a></code> for terminated task;</li>
<li>call to <code><a class="el" href="tn__tasks_8h.html#abb88bc8b1cec6b82e7b6e2e90d0e155a" title="Wake up task from sleep. ">tn_task_wakeup()</a></code>/<code><a class="el" href="tn__tasks_8h.html#a94e6a0312013e53cf08bcf871e6f4172" title="The same as tn_task_wakeup() but for using in the ISR. ">tn_task_iwakeup()</a></code> for terminated task;</li>
<li>call to <code><a class="el" href="tn__tasks_8h.html#ae90ecdbd7d87d050c2c98ec775e6efc7" title="Release task from WAIT state, independently of the reason of waiting. ">tn_task_release_wait()</a></code>/<code><a class="el" href="tn__tasks_8h.html#aee0ef296af18733f64269386adf8a2d7" title="The same as tn_task_release_wait() but for using in the ISR. ">tn_task_irelease_wait()</a></code> for terminated task.</li>
</ul>
<p>The actual error is, of course, wrong state, not wrong context; so, TNeoKernel returns <code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876a7b6d93374f52ba4b2fc01b38b783aa4c" title="Wrong task state error: requested operation requires different task state. ">TN_RC_WSTATE</a></code> in these cases.</p>
<h2><a class="anchor" id="tnkernel_diff_release_wait"></a>
Force task releasing from wait</h2>
<p>In original TNKernel, a call to <code><a class="el" href="tn__tasks_8h.html#ae90ecdbd7d87d050c2c98ec775e6efc7" title="Release task from WAIT state, independently of the reason of waiting. ">tn_task_release_wait()</a></code> / <code><a class="el" href="tn__tasks_8h.html#aee0ef296af18733f64269386adf8a2d7" title="The same as tn_task_release_wait() but for using in the ISR. ">tn_task_irelease_wait()</a></code> causes waiting task to wake up, regardless of wait reason, and <code><a class="el" href="tn__oldsymbols_8h.html#a71970f860643e62fad7ec03076bdc1d8" title="old TNKernel name of TN_RC_OK ">TERR_NO_ERR</a></code> is returned as a wait result. Actually I believe it is bad idea to ever use <code><a class="el" href="tn__tasks_8h.html#ae90ecdbd7d87d050c2c98ec775e6efc7" title="Release task from WAIT state, independently of the reason of waiting. ">tn_task_release_wait()</a></code>, but if we have this service, error code surely should be distinguishable from normal wait completion, so, new code is added: <code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876ae5cbacb0fb01805c9003046c08bf4356" title="Task was released from waiting forcibly because some other task called tn_task_release_wait() ...">TN_RC_FORCED</a></code>, and it is returned when task wakes up because of <code><a class="el" href="tn__tasks_8h.html#ae90ecdbd7d87d050c2c98ec775e6efc7" title="Release task from WAIT state, independently of the reason of waiting. ">tn_task_release_wait()</a></code> call.</p>
<h2><a class="anchor" id="tnkernel_diff_task_sleep"></a>
Return code of tn_task_sleep()</h2>
<p>In original TNKernel, <code><a class="el" href="tn__tasks_8h.html#ad3708ae3400f11b98747ad4a1cad88fa" title="Put current task to sleep for at most timeout ticks. ">tn_task_sleep()</a></code> always returns <code><a class="el" href="tn__oldsymbols_8h.html#a71970f860643e62fad7ec03076bdc1d8" title="old TNKernel name of TN_RC_OK ">TERR_NO_ERR</a></code>, independently of what actually happened. In TNeoKernel, there are three possible return codes:</p>
<ul>
<li><code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876a5b4d73fde6b5d1c9579c02e6aafce1fb" title="Timeout (consult TN_Timeout for details). ">TN_RC_TIMEOUT</a></code> if timeout is actually in effect;</li>
<li><code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876afb291924237186f5765865256c75e639" title="Successful operation. ">TN_RC_OK</a></code> if task was woken up by some other task with <code><a class="el" href="tn__tasks_8h.html#abb88bc8b1cec6b82e7b6e2e90d0e155a" title="Wake up task from sleep. ">tn_task_wakeup()</a></code>;</li>
<li><code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876ae5cbacb0fb01805c9003046c08bf4356" title="Task was released from waiting forcibly because some other task called tn_task_release_wait() ...">TN_RC_FORCED</a></code> if task was woken up forcibly by some other task with <code><a class="el" href="tn__tasks_8h.html#ae90ecdbd7d87d050c2c98ec775e6efc7" title="Release task from WAIT state, independently of the reason of waiting. ">tn_task_release_wait()</a></code>;</li>
</ul>
<h2><a class="anchor" id="tnkernel_diff_event"></a>
Events API is changed almost completely</h2>
<p>In original TNKernel, I always found events API somewhat confusing. Why is this object named "event", but there are many flags inside, so that they can actually represent many events?</p>
<p>Meanwhile, attributes like <code>TN_EVENT_ATTR_SINGLE</code>, <code>TN_EVENT_ATTR_CLR</code> imply that "event" object is really just a single event, since it makes no sense to clear just <b>all</b> event bits when some particular event happened.</p>
<p>After all, when we call <code>tn_event_clear(&amp;my_event_obj, flags)</code>, we might expect that <code>flags</code> argument actually specifies flags to clear. But in fact, we must invert it, to make it work: <code>~flags</code>. This is really confusing.</p>
<p>In TNeoKernel, there is no such <em>event</em> object. Instead, there is object <em>events group</em>. Attributes like <code>...SINGLE</code>, <code>...MULTI</code>, <code>...CLR</code> are removed, since they make no sense for events group. I have plans to offer a way to <em>connect</em> events group to queue and probably other kernel objects as well, so that queue will set and clear particular flag in the events group automatically, depending on whether a queue is empty. By means of that, it is quite easy to wait for data from multiple queues with just a single call to <code><a class="el" href="tn__eventgrp_8h.html#aee53d0c38f050ee6eecbdce19548b157" title="Wait for specified event(s) in the event group. ">tn_eventgrp_wait()</a></code>.</p>
<p>For detailed API reference, refer to the <code><a class="el" href="tn__eventgrp_8h.html" title="Event group. ">tn_eventgrp.h</a></code>.</p>
<h2><a class="anchor" id="tnkernel_diff_zero_timeout"></a>
Zero timeout given to system functions</h2>
<p>In original TNKernel, system functions refused to perform job and returned <code><a class="el" href="tn__oldsymbols_8h.html#a35ec519d54f884d84c5814f49f00a22b" title="old TNKernel name of TN_RC_WPARAM ">TERR_WRONG_PARAM</a></code> if <code>timeout</code> is 0, but it is actually neither convenient nor intuitive: it is much better if the function behaves just like <code>...polling()</code> version of the function. All TNeoKernel system functions allows timeout to be zero: in this case, function doesn't wait.</p>
<h1><a class="anchor" id="tnkernel_new_api"></a>
Compatible API changes</h1>
<h2><a class="anchor" id="tnkernel_diff_make_alig"></a>
Macro MAKE_ALIG()</h2>
<p>There is a terrible mess with <code><a class="el" href="tn__oldsymbols_8h.html#aa42d2e6b5b7ff37bd485803fa2cb70a8" title="old TNKernel name of TN_MAKE_ALIG macro ">MAKE_ALIG()</a></code> macro: TNKernel docs specify that the argument of it should be the size to align, but almost all ports, including original one, defined it so that it takes type, not size.</p>
<p>But the port by AlexB implemented it differently (i.e. accordingly to the docs) : it takes size as an argument.</p>
<p>When I was moving from the port by AlexB to another one, do you have any idea how much time it took me to figure out why do I have rare weird bug? :)</p>
<p>By the way, additional strange thing: why doesn't this macro have any prefix like <code>TN_</code>?</p>
<p>TNeoKernel provides macro <code><a class="el" href="tn__common_8h.html#a3f48380e8a624edc643319a81192d88e" title="Macro for making a number a multiple of sizeof(TN_UWord), should be used with fixed memory block pool...">TN_MAKE_ALIG_SIZE()</a></code> whose argument is <b>size</b>, so, its usage is as follows: <code><a class="el" href="tn__common_8h.html#a3f48380e8a624edc643319a81192d88e" title="Macro for making a number a multiple of sizeof(TN_UWord), should be used with fixed memory block pool...">TN_MAKE_ALIG_SIZE(sizeof(struct MyStruct))</a></code>. This macro is preferred.</p>
<p>But for compatibility with messy <code><a class="el" href="tn__oldsymbols_8h.html#aa42d2e6b5b7ff37bd485803fa2cb70a8" title="old TNKernel name of TN_MAKE_ALIG macro ">MAKE_ALIG()</a></code> from original TNKernel, there is an option <code><a class="el" href="tn__cfg__default_8h.html#a2a1148efc6a74131cc83ee50cbc386cd" title="API option for MAKE_ALIG() macro. ">TN_API_MAKE_ALIG_ARG</a></code> with two possible values;</p>
<ul>
<li><code><a class="el" href="tn__common_8h.html#a4972bf0cbc72e51a7463cf7d786d2b64" title="In this case, you should use macro like this: TN_MAKE_ALIG(sizeof(struct my_struct)). ">TN_API_MAKE_ALIG_ARG__SIZE</a></code> - default value, use macro like this: <code><a class="el" href="tn__oldsymbols_8h.html#aa42d2e6b5b7ff37bd485803fa2cb70a8" title="old TNKernel name of TN_MAKE_ALIG macro ">MAKE_ALIG(sizeof(struct my_struct))</a></code>, like in the port by Alex.</li>
<li><code><a class="el" href="tn__common_8h.html#a04321413cf21754a05682b298df0493d" title="In this case, you should use macro like this: TN_MAKE_ALIG(struct my_struct). ">TN_API_MAKE_ALIG_ARG__TYPE</a></code> - use macro like this: <code><a class="el" href="tn__oldsymbols_8h.html#aa42d2e6b5b7ff37bd485803fa2cb70a8" title="old TNKernel name of TN_MAKE_ALIG macro ">MAKE_ALIG(struct my_struct)</a></code>, like in any other port.</li>
</ul>
<p>By the way, I wrote to the author of TNKernel (Yuri Tiomkin) about this mess, but he didn't answer anything. It's a pity of course, but we have what we have.</p>
<h2><a class="anchor" id="tnkernel_diff_mutex_rec"></a>
Recursive mutexes</h2>
<p>Sometimes I feel lack of mutexes that allow recursive locking. Yeah I know there are developers who believe that recursive locking leads to the code of lower quality, and I understand it. Even Linux kernel doesn't have recursive mutexes.</p>
<p>Sometimes they are really useful though (say, if you want to use some third-party library that requires locking primitives to be recursive), so I decided to implement an option for that: <code><a class="el" href="tn__cfg__default_8h.html#a2557da78508c4241aceee92475df3581" title="Whether mutexes should allow recursive locking/unlocking. ">TN_MUTEX_REC</a></code>. If it is non-zero, mutexes allow recursive locking; otherwise you get <code><a class="el" href="tn__common_8h.html#aa43bd3da1ad4c1e61224b5f23b369876a2c83a60bf543df45b5045d6f7fbc7d0c" title="Illegal usage. ">TN_RC_ILLEGAL_USE</a></code> when you try to lock mutex that is already locked by this task. Default value: <code>1</code>.</p>
<h2><a class="anchor" id="tnkernel_new_api__convenience_macros_stack"></a>
Convenience macros for stack arrays definition</h2>
<p>You can still use "manual" definition of stack arrays, like that:</p>
<div class="fragment"><div class="line"><a class="code" href="tn__arch__example_8h.html#ae245dddb19cd7c12b7038a62d576fafa">TN_ARCH_STK_ATTR_BEFORE</a></div>
<div class="line"><a class="code" href="tn__arch__example_8h.html#ab80cba0fe9ffcd9011d53dfeb9e39bf4">TN_UWord</a> my_task_stack[ MY_TASK_STACK_SIZE ]</div>
<div class="line"><a class="code" href="tn__arch__example_8h.html#ab082613959b539182b8b47bc87d18d6a">TN_ARCH_STK_ATTR_AFTER</a>;</div>
</div><!-- fragment --><p>Although it is recommended to use convenience macro for that: <code><a class="el" href="tn__tasks_8h.html#a120e01d9dddd21ac11827595e88d7c36" title="Convenience macro for the definition of stack array. ">TN_TASK_STACK_DEF()</a></code>. See <code><a class="el" href="tn__tasks_8h.html#a548d5adda09d1b4e393b5df0e9e1a7a5" title="Construct task and probably start it (depends on options, see below). ">tn_task_create()</a></code> for the usage example.</p>
<h2><a class="anchor" id="tnkernel_new_api__convenience_macros_fmem"></a>
Convenience macros for fixed memory block pool buffers definition</h2>
<p>Similarly to the previous section, you can still use "manual" definition of the buffer for fixed memory block pool, it is recommended to use convenience macro for that: <code><a class="el" href="tn__fmem_8h.html#ab45e9c2ad4a64345214f9a912bf76fc3" title="Convenience macro for the definition of buffer for memory pool. ">TN_FMEM_BUF_DEF()</a></code>. See <code><a class="el" href="tn__fmem_8h.html#a56d47d4a1b6453d959336448a0ce96ac" title="Construct fixed memory blocks pool. ">tn_fmem_create()</a></code> for usage example.</p>
<h2><a class="anchor" id="tnkernel_diff_api_rename"></a>
Things renamed</h2>
<p>In original TNKernel thare is a lot of inconsistency with naming stuff:</p>
<ul>
<li>Why do we have <code><a class="el" href="tn__dqueue_8h.html#af60c61c12ed90f4bcc7d13ca4da8562b" title="The same as tn_queue_send() with zero timeout. ">tn_queue_send_polling()</a></code> / <code><a class="el" href="tn__dqueue_8h.html#ac059f15f07625ca25e4aac5790cce1ea" title="The same as tn_queue_send() with zero timeout, but for using in the ISR. ">tn_queue_isend_polling()</a></code> (notice the <code>i</code> letter before the verb, not before <code>polling</code>), but <code><a class="el" href="tn__fmem_8h.html#affea42ad41734fadfe8170b4234ca567" title="The same as tn_fmem_get() with zero timeout. ">tn_fmem_get_polling()</a></code> / <code><a class="el" href="tn__oldsymbols_8h.html#a4293c359514306825a9007f071b2ad3f" title="old TNKernel name of tn_fmem_iget_polling ">tn_fmem_get_ipolling()</a></code> (notice the <code>i</code> letter before <code>polling</code>)?</li>
<li>All the system service names follow the naming scheme <code>tn_&lt;noun&gt;_&lt;verb&gt;[_&lt;adjustment&gt;]()</code>, but the <code><a class="el" href="tn__oldsymbols_8h.html#a566625be14a6eed4a3574e3d31e776fc" title="old TNKernel name of tn_sys_start ">tn_start_system()</a></code> is special, for some strange reason. To make it consistent, it should be named <code>tn_system_start()</code> or <code><a class="el" href="tn__sys_8h.html#a62ab25d9d8ca01c02d368968f19e49bf" title="Initial TNeoKernel system start function, never returns. ">tn_sys_start()</a></code>;</li>
<li>A lot of macros don't have <code>TN_</code> prefix;</li>
<li>etc</li>
</ul>
<p>So, a lot of things (functions, macros, etc) has renamed. Old names are also available through <code><a class="el" href="tn__oldsymbols_8h.html" title="Compatibility layer for old projects that use old TNKernel names; usage of them in new projects is di...">tn_oldsymbols.h</a></code>, which is included automatically if <code><a class="el" href="tn__cfg__default_8h.html#ae9854c723c6a823c9126aa8390977d39" title="Whether old TNKernel names (definitions, functions, etc) should be available. ">TN_OLD_TNKERNEL_NAMES</a></code> option is non-zero.</p>
<h1><a class="anchor" id="tnkernel_diff_other"></a>
Changes that do not affect API directly</h1>
<h2><a class="anchor" id="tnkernel_diff_timer_task"></a>
No timer task</h2>
<p>Yes, timer task's job is important: it manages <code>tn_wait_timeout_list</code>, i.e. it wakes up tasks whose timeout is expired. But it's actually better to do it right in <code><a class="el" href="tn__sys_8h.html#a944d96c7a5d442d271115b6cb22a085b" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> that is called from timer ISR, because presence of the special task provides significant overhead. Look at what happens when timer interrupt is fired (assume we don't use shadow register set for that, which is almost always the case):</p>
<p>(measurements were made at PIC32 port)</p>
<ul>
<li>Current context (23 words) is saved to the interrupt stack;</li>
<li>ISR called: particularly, <code><a class="el" href="tn__sys_8h.html#a944d96c7a5d442d271115b6cb22a085b" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> is called;</li>
<li><code><a class="el" href="tn__sys_8h.html#a944d96c7a5d442d271115b6cb22a085b" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> disables interrupts, manages round-robin (if needed), then it wakes up <code>tn_timer_task</code>, sets <code>tn_next_task_to_run</code>, and enables interrupts back;</li>
<li><code><a class="el" href="tn__sys_8h.html#a944d96c7a5d442d271115b6cb22a085b" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> finishes, so ISR macro checks that <code>tn_next_task_to_run</code> is different from <code>tn_curr_run_task</code>, and sets <code>CS0</code> interrupt bit, so that context should be switched as soon as possible;</li>
<li>Context (23 words) gets restored to whatever task we interrupted;</li>
<li><code>CS0</code> ISR is immediately called, so full context (32 words) gets saved on task's stack, and context of <code>tn_timer_task</code> is restored;</li>
<li><code>tn_timer_task</code> disables interrupts, performs its not so big job (manages <code>tn_wait_timeout_list</code>), puts itself to wait, enables interrupts and pends context switching again;</li>
<li><code>CS0</code> ISR is immediately called, so full context of <code>tn_timer_task</code> gets saved in its stack, and then, after all, context of my own interrupted task gets restored and my task continues to run.</li>
</ul>
<p>I've measured with MPLABX's stopwatch how much time it takes: with just three tasks (idle task, timer task, my own task with priority 6), i.e. without any sleeping tasks, all this routine takes <b>682 cycles</b>. So I tried to get rid of <code>tn_timer_task</code> and perform its job right in the <code><a class="el" href="tn__sys_8h.html#a944d96c7a5d442d271115b6cb22a085b" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code>.</p>
<p>Previously, application callback was called from timer task; since it is removed now, startup routine has changed, refer to <a class="el" href="quick_guide.html#starting_the_kernel">Starting the kernel</a> for details.</p>
<p>Now, the following steps are performed when timer interrupt is fired:</p>
<ul>
<li>Current context (23 words) is saved to the interrupt stack;</li>
<li>ISR called: particularly, <code><a class="el" href="tn__sys_8h.html#a944d96c7a5d442d271115b6cb22a085b" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> is called;</li>
<li><code><a class="el" href="tn__sys_8h.html#a944d96c7a5d442d271115b6cb22a085b" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> disables interrupts, manages round-robin (if needed), manages <code>tn_wait_timeout_list</code>, and enables interrupts back;</li>
<li><code><a class="el" href="tn__sys_8h.html#a944d96c7a5d442d271115b6cb22a085b" title="Process system tick; should be called periodically, typically from some kind of timer ISR...">tn_tick_int_processing()</a></code> finishes, ISR macro checks that <code>tn_next_task_to_run</code> is the same as <code>tn_curr_run_task</code></li>
<li>Context (23 words) gets restored to whatever task we interrupted;</li>
</ul>
<p>That's all. It takes <b>251 cycles</b>: 2.7 times less.</p>
<p>So, we need to make sure that interrupt stack size is enough for this (not big) job. As a result, RAM is saved (since you don't need to allocate stack for timer task) and things work much faster. Win-win. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 2 2014 03:07:03 for TNeoKernel by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
