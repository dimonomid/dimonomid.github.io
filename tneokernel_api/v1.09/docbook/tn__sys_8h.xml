<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_tn__sys_8h">
<title>core/tn_sys.h File Reference</title>
<indexterm><primary>core/tn_sys.h</primary></indexterm>
<section>
<title>Detailed Description</title>

<para>Kernel system routines: system start, tick processing, time slice managing. </para>
<simplesect>
    <title>Data Structures    </title>
        <itemizedlist>
            <listitem><para>struct <link linkend="_struct__TN__BuildCfg">_TN_BuildCfg</link></para>

<para>Structure with build-time configurations values; it is needed for run-time check which ensures that build-time options for the kernel match ones for the application. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Macros    </title>
        <itemizedlist>
            <listitem><para>#define <link linkend="_tn__sys_8h_1ad61af0f0e9ab96bdf1ac1bf1e03e3c75">TN_STACK_ARR_DEF</link>(name,  size)</para>

<para>Convenience macro for the definition of stack array. </para>
</listitem>
            <listitem><para>#define <link linkend="_tn__sys_8h_1ad98662c1f06abe650958bbf208414e18">_TN_BUILD_CFG_ARCH_STRUCT_FILL</link>(_p_struct)</para>

<para>For internal kernel usage: helper macro that fills architecture-dependent values. </para>
</listitem>
            <listitem><para>#define <link linkend="_tn__sys_8h_1a7784d4218225b2cbd087628bad0d544a">_TN_BUILD_CFG_STRUCT_FILL</link>(_p_struct)</para>

<para>For internal kernel usage: fill the structure <computeroutput>#<link linkend="_struct__TN__BuildCfg">_TN_BuildCfg</link></computeroutput> with current build-time configuration values. </para>
</listitem>
            <listitem><para><anchor xml:id="_tn__sys_8h_1af26252bf220b89153a9fe6f5daf81237"/>#define <link linkend="_tn__sys_8h_1af26252bf220b89153a9fe6f5daf81237">_TN_MAX_INLINED_FUNC</link>   /* nothing */</para>

<para>For internal kernel usage: helper macro that allows functions to be inlined or not depending on configuration (see <computeroutput>#TN_MAX_INLINE</computeroutput>) </para>
</listitem>
            <listitem><para><anchor xml:id="_tn__sys_8h_1ab389cb36d15c2390d7868b10391c9b49"/>#define <link linkend="_tn__sys_8h_1ab389cb36d15c2390d7868b10391c9b49">TN_NO_TIME_SLICE</link>   0</para>

<para>Value to pass to <computeroutput><link linkend="_tn__sys_8h_1a05fc370b6faa604fd8ff9411361c4cd0">tn_sys_tslice_set()</link></computeroutput> to turn round-robin off. </para>
</listitem>
            <listitem><para><anchor xml:id="_tn__sys_8h_1a546b128561cc3bf46d0423bad1f5c8c7"/>#define <link linkend="_tn__sys_8h_1a546b128561cc3bf46d0423bad1f5c8c7">TN_MAX_TIME_SLICE</link>   0xFFFE</para>

<para>Max value of time slice. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Typedefs    </title>
        <itemizedlist>
            <listitem><para>typedef void() <link linkend="_tn__sys_8h_1aaa9bbc6c586cf6ce8d982b8d79bc27d6">TN_CBUserTaskCreate</link>(void)</para>

<para>User-provided callback function that is called directly from <computeroutput><link linkend="_tn__sys_8h_1a62ab25d9d8ca01c02d368968f19e49bf">tn_sys_start()</link></computeroutput> as a part of system startup routine; it should merely create at least one (and typically just one) user&apos;s task, which should perform all the rest application initialization. </para>
</listitem>
            <listitem><para>typedef void() <link linkend="_tn__sys_8h_1ac3811d563ff671cb7bd1519735e20fd1">TN_CBIdle</link>(void)</para>

<para>User-provided callback function which is called repeatedly from the idle task loop. </para>
</listitem>
            <listitem><para>typedef void() <link linkend="_tn__sys_8h_1a64b76c41f847eff5ee6c8bb0f337c946">TN_CBStackOverflow</link>(struct <link linkend="_structTN__Task">TN_Task</link> *task)</para>

<para>User-provided callback function that is called when the kernel detects stack overflow (see <computeroutput>#TN_STACK_OVERFLOW_CHECK</computeroutput>). </para>
</listitem>
            <listitem><para>typedef void() <link linkend="_tn__sys_8h_1a3a0439b7ba640754949f6d2c8e4ccc06">TN_CBDeadlock</link>(<link linkend="_tn__common_8h_1a9f76389d1506addfc7542f54e484a92c">TN_BOOL</link> active, struct <link linkend="_structTN__Mutex">TN_Mutex</link> *mutex, struct <link linkend="_structTN__Task">TN_Task</link> *task)</para>

<para>User-provided callback function that is called whenever deadlock becomes active or inactive. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Enumerations    </title>
        <itemizedlist>
            <listitem><para>enum <link linkend="_tn__sys_8h_1ace9542d94b996fb2070cd57d6658a2d8">TN_StateFlag</link> { <link linkend="_tn__sys_8h_1ace9542d94b996fb2070cd57d6658a2d8aa5085b1c78bc7e75aeac04a76cab6a52">TN_STATE_FLAG__SYS_RUNNING</link> = (1 &lt;&lt; 0), 
<link linkend="_tn__sys_8h_1ace9542d94b996fb2070cd57d6658a2d8a188c405a2cde555e7aaaeaa1189a4580">TN_STATE_FLAG__DEADLOCK</link> = (1 &lt;&lt; 1)
 }</para>

<para>System state flags. </para>
</listitem>
            <listitem><para>enum <link linkend="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51">TN_Context</link> { <link linkend="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51ac6015804609fb2bb71335015c51c40a3">TN_CONTEXT_NONE</link>, 
<link linkend="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51ab78bafeb369a85700f793a7375e38ec6">TN_CONTEXT_TASK</link>, 
<link linkend="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51a4b0defef531f47e8cf5dc274355b6626">TN_CONTEXT_ISR</link>
 }</para>

<para>System context. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Functions    </title>
        <itemizedlist>
            <listitem><para>void <link linkend="_tn__sys_8h_1a62ab25d9d8ca01c02d368968f19e49bf">tn_sys_start</link> (<link linkend="_tn__arch__example_8h_1ab80cba0fe9ffcd9011d53dfeb9e39bf4">TN_UWord</link> *idle_task_stack, unsigned int idle_task_stack_size, <link linkend="_tn__arch__example_8h_1ab80cba0fe9ffcd9011d53dfeb9e39bf4">TN_UWord</link> *int_stack, unsigned int int_stack_size, <link linkend="_tn__sys_8h_1aaa9bbc6c586cf6ce8d982b8d79bc27d6">TN_CBUserTaskCreate</link> *cb_user_task_create, <link linkend="_tn__sys_8h_1ac3811d563ff671cb7bd1519735e20fd1">TN_CBIdle</link> *cb_idle)</para>

<para>Initial TNeo system start function, never returns. </para>
</listitem>
            <listitem><para>void <link linkend="_tn__sys_8h_1aa44d297639e0520420890ef2bb7e2c1c">tn_tick_int_processing</link> (void)</para>

<para>Process system tick; should be called periodically, typically from some kind of timer ISR. </para>
</listitem>
            <listitem><para>enum <link linkend="_tn__common_8h_1aa43bd3da1ad4c1e61224b5f23b369876">TN_RCode</link> <link linkend="_tn__sys_8h_1a05fc370b6faa604fd8ff9411361c4cd0">tn_sys_tslice_set</link> (int priority, int ticks)</para>

<para>Set time slice ticks value for specified priority (see <link linkend="_quick_guide_1round_robin">Round-robin scheduling</link>). </para>
</listitem>
            <listitem><para><link linkend="_tn__common_8h_1ac885b63d00c063de61cdbd80bf26d8aa">TN_TickCnt</link> <link linkend="_tn__sys_8h_1a4864ca85d87bab0fa95ce11aefcd1a92">tn_sys_time_get</link> (void)</para>

<para>Get current system ticks count. </para>
</listitem>
            <listitem><para>void <link linkend="_tn__sys_8h_1aaa4a5c2feb4a0db5993b81dde496edc3">tn_callback_deadlock_set</link> (<link linkend="_tn__sys_8h_1a3a0439b7ba640754949f6d2c8e4ccc06">TN_CBDeadlock</link> *cb)</para>

<para>Set callback function that should be called whenever deadlock occurs or becomes inactive (say, if one of tasks involved in the deadlock was released from wait because of timeout) </para>
</listitem>
            <listitem><para>void <link linkend="_tn__sys_8h_1ab40a7069739439d7b70cc4e19d0b9fe3">tn_callback_stack_overflow_set</link> (<link linkend="_tn__sys_8h_1a64b76c41f847eff5ee6c8bb0f337c946">TN_CBStackOverflow</link> *cb)</para>

<para>Set callback function that is called when the kernel detects stack overflow (see <computeroutput>#TN_STACK_OVERFLOW_CHECK</computeroutput>). </para>
</listitem>
            <listitem><para>enum <link linkend="_tn__sys_8h_1ace9542d94b996fb2070cd57d6658a2d8">TN_StateFlag</link> <link linkend="_tn__sys_8h_1a202fb30400101599c1e39ba4e58d2fd5">tn_sys_state_flags_get</link> (void)</para>

<para>Returns current system state flags. </para>
</listitem>
            <listitem><para>enum <link linkend="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51">TN_Context</link> <link linkend="_tn__sys_8h_1ac3233931746c9d8b84ebd34a2a3a468a">tn_sys_context_get</link> (void)</para>

<para>Returns system context: task or ISR. </para>
</listitem>
            <listitem><para><link linkend="_tn__arch__example_8h_1a39b8c7b5ae653ec71be6f5a821eec3f6">_TN_STATIC_INLINE</link> <link linkend="_tn__common_8h_1a9f76389d1506addfc7542f54e484a92c">TN_BOOL</link> <link linkend="_tn__sys_8h_1a75204c95f65f14283921931b3baada0a">tn_is_task_context</link> (void)</para>

<para>Returns whether current system context is <computeroutput>#TN_CONTEXT_TASK</computeroutput> </para>
</listitem>
            <listitem><para><link linkend="_tn__arch__example_8h_1a39b8c7b5ae653ec71be6f5a821eec3f6">_TN_STATIC_INLINE</link> <link linkend="_tn__common_8h_1a9f76389d1506addfc7542f54e484a92c">TN_BOOL</link> <link linkend="_tn__sys_8h_1ad2b1d9eba4ab359a2632ecd986f4a42b">tn_is_isr_context</link> (void)</para>

<para>Returns whether current system context is <computeroutput>#TN_CONTEXT_ISR</computeroutput> </para>
</listitem>
            <listitem><para>struct <link linkend="_structTN__Task">TN_Task</link> * <link linkend="_tn__sys_8h_1a2ca353dcf362a5aa8d2e5a3960e51410">tn_cur_task_get</link> (void)</para>

<para>Returns pointer to the currently running task. </para>
</listitem>
            <listitem><para><link linkend="_tn__common_8h_1a603cbe1ffdafc7e6813ef692bbd7d22f">TN_TaskBody</link> * <link linkend="_tn__sys_8h_1afa3c83dce52b17c9ee07b34af0fcebab">tn_cur_task_body_get</link> (void)</para>

<para>Returns pointer to the body function of the currently running task. </para>
</listitem>
            <listitem><para><link linkend="_tn__arch__example_8h_1a39b8c7b5ae653ec71be6f5a821eec3f6">_TN_STATIC_INLINE</link> <link linkend="_tn__arch__example_8h_1ab80cba0fe9ffcd9011d53dfeb9e39bf4">TN_UWord</link> <link linkend="_tn__sys_8h_1af1502619506a9c92eb954e45ff0f461b">tn_sched_dis_save</link> (void)</para>

<para>Disable kernel scheduler and return previous scheduler state. </para>
</listitem>
            <listitem><para><link linkend="_tn__arch__example_8h_1a39b8c7b5ae653ec71be6f5a821eec3f6">_TN_STATIC_INLINE</link> void <link linkend="_tn__sys_8h_1a4cd5c9113872b2008184c567907653bd">tn_sched_restore</link> (<link linkend="_tn__arch__example_8h_1ab80cba0fe9ffcd9011d53dfeb9e39bf4">TN_UWord</link> sched_state)</para>

<para>Restore state of the kernel scheduler. </para>
</listitem>
            <listitem><para>void <link linkend="_tn__sys_8h_1ab4e879240635c8f73e20905b8e499c1c">tn_callback_dyn_tick_set</link> (<link linkend="_tn__timer_8h_1a8c64f098ee0fa587a985d149b81bfba9">TN_CBTickSchedule</link> *cb_tick_schedule, <link linkend="_tn__timer_8h_1a4cc3440639e990e3a3015b95e805374a">TN_CBTickCntGet</link> *cb_tick_cnt_get)</para>

<para><emphasis>Available if only <link linkend="_tn__cfg__default_8h_1aaee875834a86f961318c584095c366fe"><computeroutput>TN_DYNAMIC_TICK</computeroutput> </link> is <emphasis role="bold">set</emphasis>.</emphasis> </para>
</listitem>
        </itemizedlist>
</simplesect>
</section>
<section>
<title>Macro Definition Documentation</title>
<anchor xml:id="_tn__sys_8h_1ad61af0f0e9ab96bdf1ac1bf1e03e3c75"/>    <section>
    <title>TN_STACK_ARR_DEF</title>
<indexterm><primary>TN_STACK_ARR_DEF</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>TN_STACK_ARR_DEF</secondary></indexterm>
<para><computeroutput>#define TN_STACK_ARR_DEF( name,  size)</computeroutput></para><emphasis role="strong">Value:</emphasis><programlisting>&#32;&#32;&#32;TN_ARCH_STK_ATTR_BEFORE&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;TN_UWord&#32;name[&#32;(size)&#32;]&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;<link linkend="_tn__arch__example_8h_1ab082613959b539182b8b47bc87d18d6a">TN_ARCH_STK_ATTR_AFTER</link>
</programlisting><para>

<para>Convenience macro for the definition of stack array. </para>
</para>

<para>See <computeroutput><link linkend="_tn__tasks_8h_1a548d5adda09d1b4e393b5df0e9e1a7a5">tn_task_create()</link></computeroutput> for the usage example.</para>

<para>
                <formalpara>
                    <title>
Parameters                    </title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>name</entry>
                                <entry>
<para>C variable name of the array </para>
</entry>
                            </row>
                            <row>
                                <entry>size</entry>
                                <entry>
<para>size of the stack array in words (<computeroutput>#TN_UWord</computeroutput>), not in bytes. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
<para>
Definition at line 87 of file tn_sys.h.</para>
    </section><anchor xml:id="_tn__sys_8h_1ad98662c1f06abe650958bbf208414e18"/>    <section>
    <title>_TN_BUILD_CFG_ARCH_STRUCT_FILL</title>
<indexterm><primary>_TN_BUILD_CFG_ARCH_STRUCT_FILL</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>_TN_BUILD_CFG_ARCH_STRUCT_FILL</secondary></indexterm>
<para><computeroutput>#define _TN_BUILD_CFG_ARCH_STRUCT_FILL( _p_struct)</computeroutput></para><para>

<para>For internal kernel usage: helper macro that fills architecture-dependent values. </para>
</para>

<para>This macro is used by <computeroutput>#<link linkend="_tn__sys_8h_1a7784d4218225b2cbd087628bad0d544a">_TN_BUILD_CFG_STRUCT_FILL()</link></computeroutput> only. </para>
<para>
Definition at line 107 of file tn_sys.h.</para>
    </section><anchor xml:id="_tn__sys_8h_1a7784d4218225b2cbd087628bad0d544a"/>    <section>
    <title>_TN_BUILD_CFG_STRUCT_FILL</title>
<indexterm><primary>_TN_BUILD_CFG_STRUCT_FILL</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>_TN_BUILD_CFG_STRUCT_FILL</secondary></indexterm>
<para><computeroutput>#define _TN_BUILD_CFG_STRUCT_FILL( _p_struct)</computeroutput></para><emphasis role="strong">Value:</emphasis><programlisting>{&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;memset((_p_struct),&#32;0x00,&#32;<emphasis role="keyword">sizeof</emphasis>(*(_p_struct)));&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;(_p_struct)-&gt;priorities_cnt&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;<link linkend="_tn__cfg__default_8h_1aad74a059c61567c68a1e9067ab47a256">TN_PRIORITIES_CNT</link>;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;(_p_struct)-&gt;check_param&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;<link linkend="_tn__cfg__default_8h_1a1f197294df3276fec431930545acafd5">TN_CHECK_PARAM</link>;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;(_p_struct)-&gt;debug&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;<link linkend="_tn__cfg__default_8h_1a9d2b6d902efdbc56094bb913413aa69c">TN_DEBUG</link>;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;(_p_struct)-&gt;use_mutexes&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;<link linkend="_tn__cfg__default_8h_1a7ce674edab5345c4b8d2ec251eea18eb">TN_USE_MUTEXES</link>;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;(_p_struct)-&gt;mutex_rec&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;<link linkend="_tn__cfg__default_8h_1a2557da78508c4241aceee92475df3581">TN_MUTEX_REC</link>;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;(_p_struct)-&gt;mutex_deadlock_detect&#32;&#32;&#32;&#32;&#32;=&#32;<link linkend="_tn__cfg__default_8h_1a6ed3ec7b0d4338e7f60dde86b7ea5fa4">TN_MUTEX_DEADLOCK_DETECT</link>;&#32;&#32;&#32;\
&#32;&#32;&#32;(_p_struct)-&gt;tick_lists_cnt_minus_one&#32;&#32;=&#32;(<link linkend="_tn__cfg__default_8h_1afef2a6ec1baa81edaa979024af0c924a">TN_TICK_LISTS_CNT</link>&#32;-&#32;1);&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;(_p_struct)-&gt;api_make_alig_arg&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;<link linkend="_tn__cfg__default_8h_1a2a1148efc6a74131cc83ee50cbc386cd">TN_API_MAKE_ALIG_ARG</link>;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;(_p_struct)-&gt;profiler&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;<link linkend="_tn__cfg__default_8h_1a49a546b18cc1f75b51d4cf8b290634dd">TN_PROFILER</link>;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;(_p_struct)-&gt;profiler_wait_time&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;<link linkend="_tn__cfg__default_8h_1a1c04db5457adb54f7cc38d42b29a5ad7">TN_PROFILER_WAIT_TIME</link>;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;(_p_struct)-&gt;stack_overflow_check&#32;&#32;&#32;&#32;&#32;&#32;=&#32;<link linkend="_tn__cfg__default_8h_1ac6a9bbac3b3b25d9b5bc8c21d2e09955">TN_STACK_OVERFLOW_CHECK</link>;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;(_p_struct)-&gt;dynamic_tick&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;<link linkend="_tn__cfg__default_8h_1aaee875834a86f961318c584095c366fe">TN_DYNAMIC_TICK</link>;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
&#32;&#32;&#32;(_p_struct)-&gt;old_events_api&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;<link linkend="_tn__cfg__default_8h_1ac61d5f6a716cdcab205a2c8afbde4242">TN_OLD_EVENT_API</link>;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_tn__sys_8h_1ad98662c1f06abe650958bbf208414e18">\</link>
<link linkend="_tn__sys_8h_1ad98662c1f06abe650958bbf208414e18">                                                                        \</link>
<link linkend="_tn__sys_8h_1ad98662c1f06abe650958bbf208414e18">   _TN_BUILD_CFG_ARCH_STRUCT_FILL</link>(_p_struct);&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\
}
</programlisting><para>

<para>For internal kernel usage: fill the structure <computeroutput>#<link linkend="_struct__TN__BuildCfg">_TN_BuildCfg</link></computeroutput> with current build-time configuration values. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters                    </title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>_p_struct</entry>
                                <entry>
<para>Pointer to struct <computeroutput>#<link linkend="_struct__TN__BuildCfg">_TN_BuildCfg</link></computeroutput> </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
<para>
Definition at line 119 of file tn_sys.h.</para>
</section>
</section>
<section>
<title>Typedef Documentation</title>
<anchor xml:id="_tn__sys_8h_1aaa9bbc6c586cf6ce8d982b8d79bc27d6"/>    <section>
    <title>TN_CBUserTaskCreate</title>
<indexterm><primary>TN_CBUserTaskCreate</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>TN_CBUserTaskCreate</secondary></indexterm>
<para><computeroutput>typedef void() TN_CBUserTaskCreate(void)</computeroutput></para><para>

<para>User-provided callback function that is called directly from <computeroutput><link linkend="_tn__sys_8h_1a62ab25d9d8ca01c02d368968f19e49bf">tn_sys_start()</link></computeroutput> as a part of system startup routine; it should merely create at least one (and typically just one) user&apos;s task, which should perform all the rest application initialization. </para>
</para>

<para>When <computeroutput><link linkend="_tn__sys_8h_1aaa9bbc6c586cf6ce8d982b8d79bc27d6">TN_CBUserTaskCreate()</link></computeroutput> returned, the kernel performs first context switch to the task with highest priority. If there are several tasks with highest priority, context is switched to the first created one.</para>

<para>Refer to the section <link linkend="_quick_guide_1starting_the_kernel">Starting the kernel</link> for details about system startup process on the whole.</para>

<para><emphasis role="bold">Note:</emphasis> Although you&apos;re able to create more than one task here, it&apos;s usually not so good idea, because many things typically should be done at startup before tasks can go on with their job: we need to initialize various on-board peripherals (displays, flash memory chips, or whatever) as well as initialize software modules used by application. So, if many tasks are created here, you have to provide some synchronization object so that tasks will wait until all the initialization is done.</para>

<para>It&apos;s usually easier to maintain if we create just one task here, which firstly performs all the necessary initialization, <emphasis role="bold">then</emphasis> creates the rest of your tasks, and eventually gets to its primary job (the job for which task was created at all). For the usage example, refer to the page <link linkend="_quick_guide_1starting_the_kernel">Starting the kernel</link>.</para>

<para><caution><title>Attention</title>

<para><itemizedlist>
<listitem>
<para>The only system service is allowed to call in this function is <computeroutput><link linkend="_tn__tasks_8h_1a548d5adda09d1b4e393b5df0e9e1a7a5">tn_task_create()</link></computeroutput>.</para>
</listitem></itemizedlist>
</para>
</caution>
<formalpara><title>See also</title>

<para><computeroutput><link linkend="_tn__sys_8h_1a62ab25d9d8ca01c02d368968f19e49bf">tn_sys_start()</link></computeroutput> </para>
</formalpara>
</para>
<para>
Definition at line 294 of file tn_sys.h.</para>
    </section><anchor xml:id="_tn__sys_8h_1ac3811d563ff671cb7bd1519735e20fd1"/>    <section>
    <title>TN_CBIdle</title>
<indexterm><primary>TN_CBIdle</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>TN_CBIdle</secondary></indexterm>
<para><computeroutput>typedef void() TN_CBIdle(void)</computeroutput></para><para>

<para>User-provided callback function which is called repeatedly from the idle task loop. </para>
</para>

<para>Make sure that idle task has enough stack space to call this function.</para>

<para>Typically, this callback can be used for things like:</para>

<para><itemizedlist>
<listitem>
<para>MCU sleep/idle mode. When system has nothing to do, it often makes sense to bring processor to some power-saving mode. Of course, the application is responsible for setting some condition to wake up: typically, it&apos;s an interrupt.</para>
</listitem><listitem>
<para>Calculation of system load. The easiest implementation is to just increment some variable in the idle task. The faster value grows, the less busy system is.</para>
</listitem></itemizedlist>
</para>

<para><caution><title>Attention</title>

<para><itemizedlist>
<listitem>
<para>From withing this callback, it is illegal to invoke <computeroutput>#<link linkend="_tn__tasks_8h_1ae768a72ca0efde5767796cc1770bd45e">tn_task_sleep()</link></computeroutput> or any other service which could put task to waiting state, because idle task (from which this function is called) should always be runnable, by design. If <computeroutput>#TN_DEBUG</computeroutput> option is set, then this is checked, so if idle task becomes non-runnable, <computeroutput>_TN_FATAL_ERROR()</computeroutput> macro will be called.</para>
</listitem></itemizedlist>
</para>
</caution>
<formalpara><title>See also</title>

<para><computeroutput><link linkend="_tn__sys_8h_1a62ab25d9d8ca01c02d368968f19e49bf">tn_sys_start()</link></computeroutput> </para>
</formalpara>
</para>
<para>
Definition at line 321 of file tn_sys.h.</para>
    </section><anchor xml:id="_tn__sys_8h_1a64b76c41f847eff5ee6c8bb0f337c946"/>    <section>
    <title>TN_CBStackOverflow</title>
<indexterm><primary>TN_CBStackOverflow</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>TN_CBStackOverflow</secondary></indexterm>
<para><computeroutput>typedef void() TN_CBStackOverflow(struct <link linkend="_structTN__Task">TN_Task</link> *task)</computeroutput></para><para>

<para>User-provided callback function that is called when the kernel detects stack overflow (see <computeroutput>#TN_STACK_OVERFLOW_CHECK</computeroutput>). </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters                    </title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>task</entry>
                                <entry>
<para>Task whose stack is overflowed </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
<para>
Definition at line 330 of file tn_sys.h.</para>
    </section><anchor xml:id="_tn__sys_8h_1a3a0439b7ba640754949f6d2c8e4ccc06"/>    <section>
    <title>TN_CBDeadlock</title>
<indexterm><primary>TN_CBDeadlock</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>TN_CBDeadlock</secondary></indexterm>
<para><computeroutput>typedef void() TN_CBDeadlock(<link linkend="_tn__common_8h_1a9f76389d1506addfc7542f54e484a92c">TN_BOOL</link> active, struct <link linkend="_structTN__Mutex">TN_Mutex</link> *mutex, struct <link linkend="_structTN__Task">TN_Task</link> *task)</computeroutput></para><para>

<para>User-provided callback function that is called whenever deadlock becomes active or inactive. </para>
</para>

<para>Note: this feature works if only <computeroutput>#TN_MUTEX_DEADLOCK_DETECT</computeroutput> is non-zero.</para>

<para>
                <formalpara>
                    <title>
Parameters                    </title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>active</entry>
                                <entry>
<para>Boolean value indicating whether deadlock becomes active or inactive. Note: deadlock might become inactive if, for example, one of tasks involved in deadlock exits from waiting by timeout.</para>
</entry>
                            </row>
                            <row>
                                <entry>mutex</entry>
                                <entry>
<para>mutex that is involved in deadlock. You may find out other mutexes involved by means of <computeroutput>mutex-&gt;deadlock_list</computeroutput>.</para>
</entry>
                            </row>
                            <row>
                                <entry>task</entry>
                                <entry>
<para>task that is involved in deadlock. You may find out other tasks involved by means of <computeroutput>task-&gt;deadlock_list</computeroutput>. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
<para>
Definition at line 350 of file tn_sys.h.</para>
</section>
</section>
<section>
<title>Enumeration Type Documentation</title>
<anchor xml:id="_tn__sys_8h_1ace9542d94b996fb2070cd57d6658a2d8"/>    <section>
    <title>TN_StateFlag</title>
<indexterm><primary>TN_StateFlag</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>TN_StateFlag</secondary></indexterm>
<para><computeroutput>enum <link linkend="_tn__sys_8h_1ace9542d94b996fb2070cd57d6658a2d8">TN_StateFlag</link></computeroutput></para><para>

<para>System state flags. </para>
</para>
<informaltable frame="all">
<title>Enumerator</title>
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
<tbody>
<row><entry><indexterm><primary>TN_STATE_FLAG__SYS_RUNNING</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>TN_STATE_FLAG__SYS_RUNNING</secondary></indexterm>
<anchor xml:id="_tn__sys_8h_1ace9542d94b996fb2070cd57d6658a2d8aa5085b1c78bc7e75aeac04a76cab6a52"/>TN_STATE_FLAG__SYS_RUNNING</entry><entry>
<para>system is running </para>
</entry></row><row><entry><indexterm><primary>TN_STATE_FLAG__DEADLOCK</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>TN_STATE_FLAG__DEADLOCK</secondary></indexterm>
<anchor xml:id="_tn__sys_8h_1ace9542d94b996fb2070cd57d6658a2d8a188c405a2cde555e7aaaeaa1189a4580"/>TN_STATE_FLAG__DEADLOCK</entry><entry>
<para>deadlock is active Note: this feature works if only <computeroutput>#TN_MUTEX_DEADLOCK_DETECT</computeroutput> is non-zero. </para>

<para><formalpara><title>See also</title>

<para><computeroutput>#<link linkend="_tn__cfg__default_8h_1a6ed3ec7b0d4338e7f60dde86b7ea5fa4">TN_MUTEX_DEADLOCK_DETECT</link></computeroutput> </para>
</formalpara>
</para>
</entry></row>    </tbody>
    </tgroup>
</informaltable>
<para>
Definition at line 232 of file tn_sys.h.</para>
    </section><anchor xml:id="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51"/>    <section>
    <title>TN_Context</title>
<indexterm><primary>TN_Context</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>TN_Context</secondary></indexterm>
<para><computeroutput>enum <link linkend="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51">TN_Context</link></computeroutput></para><para>

<para>System context. </para>
</para>

<para><formalpara><title>See also</title>

<para><computeroutput><link linkend="_tn__sys_8h_1ac3233931746c9d8b84ebd34a2a3a468a">tn_sys_context_get()</link></computeroutput> </para>
</formalpara>
</para>
<informaltable frame="all">
<title>Enumerator</title>
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
<tbody>
<row><entry><indexterm><primary>TN_CONTEXT_NONE</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>TN_CONTEXT_NONE</secondary></indexterm>
<anchor xml:id="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51ac6015804609fb2bb71335015c51c40a3"/>TN_CONTEXT_NONE</entry><entry>
<para>None: this code is possible if only system is not running (flag (<computeroutput>#TN_STATE_FLAG__SYS_RUNNING</computeroutput> is not set in the <computeroutput>_tn_sys_state</computeroutput>)) </para>
</entry></row><row><entry><indexterm><primary>TN_CONTEXT_TASK</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>TN_CONTEXT_TASK</secondary></indexterm>
<anchor xml:id="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51ab78bafeb369a85700f793a7375e38ec6"/>TN_CONTEXT_TASK</entry><entry>
<para>Task context. </para>
</entry></row><row><entry><indexterm><primary>TN_CONTEXT_ISR</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>TN_CONTEXT_ISR</secondary></indexterm>
<anchor xml:id="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51a4b0defef531f47e8cf5dc274355b6626"/>TN_CONTEXT_ISR</entry><entry>
<para>ISR context. </para>
</entry></row>    </tbody>
    </tgroup>
</informaltable>
<para>
Definition at line 248 of file tn_sys.h.</para>
</section>
</section>
<section>
<title>Function Documentation</title>
<anchor xml:id="_tn__sys_8h_1a62ab25d9d8ca01c02d368968f19e49bf"/>    <section>
    <title>tn_sys_start()</title>
<indexterm><primary>tn_sys_start</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_sys_start</secondary></indexterm>
<para><computeroutput>void tn_sys_start (<link linkend="_tn__arch__example_8h_1ab80cba0fe9ffcd9011d53dfeb9e39bf4">TN_UWord</link> * idle_task_stack, unsigned int idle_task_stack_size, <link linkend="_tn__arch__example_8h_1ab80cba0fe9ffcd9011d53dfeb9e39bf4">TN_UWord</link> * int_stack, unsigned int int_stack_size, <link linkend="_tn__sys_8h_1aaa9bbc6c586cf6ce8d982b8d79bc27d6">TN_CBUserTaskCreate</link> * cb_user_task_create, <link linkend="_tn__sys_8h_1ac3811d563ff671cb7bd1519735e20fd1">TN_CBIdle</link> * cb_idle)</computeroutput></para><para>

<para>Initial TNeo system start function, never returns. </para>
</para>

<para>Typically called from main().</para>

<para>Refer to the <link linkend="_quick_guide_1starting_the_kernel">Starting the kernel</link> section for the usage example and additional comments.</para>

<para><emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis></para>

<para>
                <formalpara>
                    <title>
Parameters                    </title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>idle_task_stack</entry>
                                <entry>
<para>
<literallayout>&#160;&#xa;</literallayout>
 Pointer to array for idle task stack. User must either use the macro <computeroutput><link linkend="_tn__sys_8h_1ad61af0f0e9ab96bdf1ac1bf1e03e3c75">TN_STACK_ARR_DEF()</link></computeroutput> for the definition of stack array, or allocate it manually as an array of <computeroutput>#TN_UWord</computeroutput> with <computeroutput>#TN_ARCH_STK_ATTR_BEFORE</computeroutput> and <computeroutput>#TN_ARCH_STK_ATTR_AFTER</computeroutput> macros. </para>
</entry>
                            </row>
                            <row>
                                <entry>idle_task_stack_size</entry>
                                <entry>
<para>Size of idle task stack, in words (<computeroutput>#TN_UWord</computeroutput>) </para>
</entry>
                            </row>
                            <row>
                                <entry>int_stack</entry>
                                <entry>
<para>
<literallayout>&#160;&#xa;</literallayout>
 Pointer to array for interrupt stack. User must either use the macro <computeroutput><link linkend="_tn__sys_8h_1ad61af0f0e9ab96bdf1ac1bf1e03e3c75">TN_STACK_ARR_DEF()</link></computeroutput> for the definition of stack array, or allocate it manually as an array of <computeroutput>#TN_UWord</computeroutput> with <computeroutput>#TN_ARCH_STK_ATTR_BEFORE</computeroutput> and <computeroutput>#TN_ARCH_STK_ATTR_AFTER</computeroutput> macros. </para>
</entry>
                            </row>
                            <row>
                                <entry>int_stack_size</entry>
                                <entry>
<para>
<literallayout>&#160;&#xa;</literallayout>
 Size of interrupt stack, in words (<computeroutput>#TN_UWord</computeroutput>) </para>
</entry>
                            </row>
                            <row>
                                <entry>cb_user_task_create</entry>
                                <entry>
<para>Callback function that should create initial user&apos;s task, see <computeroutput>#TN_CBUserTaskCreate</computeroutput> for details. </para>
</entry>
                            </row>
                            <row>
                                <entry>cb_idle</entry>
                                <entry>
<para>
<literallayout>&#160;&#xa;</literallayout>
 Callback function repeatedly called from idle task, see <computeroutput>#TN_CBIdle</computeroutput> for details. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
    </section><anchor xml:id="_tn__sys_8h_1aa44d297639e0520420890ef2bb7e2c1c"/>    <section>
    <title>tn_tick_int_processing()</title>
<indexterm><primary>tn_tick_int_processing</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_tick_int_processing</secondary></indexterm>
<para><computeroutput>void tn_tick_int_processing (void )</computeroutput></para><para>

<para>Process system tick; should be called periodically, typically from some kind of timer ISR. </para>
</para>

<para>The period of this timer is determined by user (typically 1 ms, but user is free to set different value)</para>

<para>Among other things, expired <link linkend="_tn__timer_8h">timers</link> are fired from this function.</para>

<para>For further information, refer to <link linkend="_quick_guide">Quick guide</link>.</para>

<para>    <emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis> </para>
    </section><anchor xml:id="_tn__sys_8h_1a05fc370b6faa604fd8ff9411361c4cd0"/>    <section>
    <title>tn_sys_tslice_set()</title>
<indexterm><primary>tn_sys_tslice_set</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_sys_tslice_set</secondary></indexterm>
<para><computeroutput>enum <link linkend="_tn__common_8h_1aa43bd3da1ad4c1e61224b5f23b369876">TN_RCode</link> tn_sys_tslice_set (int priority, int ticks)</computeroutput></para><para>

<para>Set time slice ticks value for specified priority (see <link linkend="_quick_guide_1round_robin">Round-robin scheduling</link>). </para>
</para>

<para>  <emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis></para>

<para>
                <formalpara>
                    <title>
Parameters                    </title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>priority</entry>
                                <entry>
<para>Priority of tasks for which time slice value should be set </para>
</entry>
                            </row>
                            <row>
                                <entry>ticks</entry>
                                <entry>
<para>Time slice value, in ticks. Set to <computeroutput>#TN_NO_TIME_SLICE</computeroutput> for no round-robin scheduling for given priority (it&apos;s default value). Value can&apos;t be higher than <computeroutput>#TN_MAX_TIME_SLICE</computeroutput>.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para><itemizedlist>
<listitem>
<para><computeroutput>#TN_RC_OK</computeroutput> on success;</para>
</listitem><listitem>
<para><computeroutput>#TN_RC_WCONTEXT</computeroutput> if called from wrong context;</para>
</listitem><listitem>
<para><computeroutput>#TN_RC_WPARAM</computeroutput> if given <computeroutput>priority</computeroutput> or <computeroutput>ticks</computeroutput> are invalid. </para>
</listitem></itemizedlist>
</para>
</formalpara>
</para>
    </section><anchor xml:id="_tn__sys_8h_1a4864ca85d87bab0fa95ce11aefcd1a92"/>    <section>
    <title>tn_sys_time_get()</title>
<indexterm><primary>tn_sys_time_get</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_sys_time_get</secondary></indexterm>
<para><computeroutput><link linkend="_tn__common_8h_1ac885b63d00c063de61cdbd80bf26d8aa">TN_TickCnt</link> tn_sys_time_get (void )</computeroutput></para><para>

<para>Get current system ticks count. </para>
</para>

<para>    <emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis></para>

<para><formalpara><title>Returns</title>

<para>Current system ticks count. </para>
</formalpara>
</para>
    </section><anchor xml:id="_tn__sys_8h_1aaa4a5c2feb4a0db5993b81dde496edc3"/>    <section>
    <title>tn_callback_deadlock_set()</title>
<indexterm><primary>tn_callback_deadlock_set</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_callback_deadlock_set</secondary></indexterm>
<para><computeroutput>void tn_callback_deadlock_set (<link linkend="_tn__sys_8h_1a3a0439b7ba640754949f6d2c8e4ccc06">TN_CBDeadlock</link> * cb)</computeroutput></para><para>

<para>Set callback function that should be called whenever deadlock occurs or becomes inactive (say, if one of tasks involved in the deadlock was released from wait because of timeout) </para>
</para>

<para><emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis></para>

<para><emphasis role="bold">Note:</emphasis> this function should be called from <computeroutput>main()</computeroutput>, before <computeroutput><link linkend="_tn__sys_8h_1a62ab25d9d8ca01c02d368968f19e49bf">tn_sys_start()</link></computeroutput>.</para>

<para>
                <formalpara>
                    <title>
Parameters                    </title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>cb</entry>
                                <entry>
<para>Pointer to user-provided callback function.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>See also</title>

<para><computeroutput>#<link linkend="_tn__cfg__default_8h_1a6ed3ec7b0d4338e7f60dde86b7ea5fa4">TN_MUTEX_DEADLOCK_DETECT</link></computeroutput> </para>

<para><computeroutput>#<link linkend="_tn__sys_8h_1a3a0439b7ba640754949f6d2c8e4ccc06">TN_CBDeadlock</link></computeroutput> for callback function prototype </para>
</formalpara>
</para>
    </section><anchor xml:id="_tn__sys_8h_1ab40a7069739439d7b70cc4e19d0b9fe3"/>    <section>
    <title>tn_callback_stack_overflow_set()</title>
<indexterm><primary>tn_callback_stack_overflow_set</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_callback_stack_overflow_set</secondary></indexterm>
<para><computeroutput>void tn_callback_stack_overflow_set (<link linkend="_tn__sys_8h_1a64b76c41f847eff5ee6c8bb0f337c946">TN_CBStackOverflow</link> * cb)</computeroutput></para><para>

<para>Set callback function that is called when the kernel detects stack overflow (see <computeroutput>#TN_STACK_OVERFLOW_CHECK</computeroutput>). </para>
</para>

<para>For function prototype, refer to <computeroutput>#TN_CBStackOverflow</computeroutput>. </para>
    </section><anchor xml:id="_tn__sys_8h_1a202fb30400101599c1e39ba4e58d2fd5"/>    <section>
    <title>tn_sys_state_flags_get()</title>
<indexterm><primary>tn_sys_state_flags_get</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_sys_state_flags_get</secondary></indexterm>
<para><computeroutput>enum <link linkend="_tn__sys_8h_1ace9542d94b996fb2070cd57d6658a2d8">TN_StateFlag</link> tn_sys_state_flags_get (void )</computeroutput></para><para>

<para>Returns current system state flags. </para>
</para>

<para>    <emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis> </para>
    </section><anchor xml:id="_tn__sys_8h_1ac3233931746c9d8b84ebd34a2a3a468a"/>    <section>
    <title>tn_sys_context_get()</title>
<indexterm><primary>tn_sys_context_get</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_sys_context_get</secondary></indexterm>
<para><computeroutput>enum <link linkend="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51">TN_Context</link> tn_sys_context_get (void )</computeroutput></para><para>

<para>Returns system context: task or ISR. </para>
</para>

<para>     <emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis></para>

<para><formalpara><title>See also</title>

<para><computeroutput>enum #<link linkend="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51">TN_Context</link></computeroutput> </para>
</formalpara>
</para>
    </section><anchor xml:id="_tn__sys_8h_1a75204c95f65f14283921931b3baada0a"/>    <section>
    <title>tn_is_task_context()</title>
<indexterm><primary>tn_is_task_context</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_is_task_context</secondary></indexterm>
<para><computeroutput><link linkend="_tn__arch__example_8h_1a39b8c7b5ae653ec71be6f5a821eec3f6">_TN_STATIC_INLINE</link> <link linkend="_tn__common_8h_1a9f76389d1506addfc7542f54e484a92c">TN_BOOL</link> tn_is_task_context (void )</computeroutput></para><para>

<para>Returns whether current system context is <computeroutput>#TN_CONTEXT_TASK</computeroutput> </para>
</para>

<para>     <emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis></para>

<para><formalpara><title>Returns</title>

<para><computeroutput>TN_TRUE</computeroutput> if current system context is <computeroutput>#TN_CONTEXT_TASK</computeroutput>, <computeroutput>TN_FALSE</computeroutput> otherwise.</para>
</formalpara>
<formalpara><title>See also</title>

<para><computeroutput><link linkend="_tn__sys_8h_1ac3233931746c9d8b84ebd34a2a3a468a">tn_sys_context_get()</link></computeroutput> </para>

<para><computeroutput>enum #<link linkend="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51">TN_Context</link></computeroutput> </para>
</formalpara>
</para>
<para>
Definition at line 533 of file tn_sys.h.</para>
    </section><anchor xml:id="_tn__sys_8h_1ad2b1d9eba4ab359a2632ecd986f4a42b"/>    <section>
    <title>tn_is_isr_context()</title>
<indexterm><primary>tn_is_isr_context</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_is_isr_context</secondary></indexterm>
<para><computeroutput><link linkend="_tn__arch__example_8h_1a39b8c7b5ae653ec71be6f5a821eec3f6">_TN_STATIC_INLINE</link> <link linkend="_tn__common_8h_1a9f76389d1506addfc7542f54e484a92c">TN_BOOL</link> tn_is_isr_context (void )</computeroutput></para><para>

<para>Returns whether current system context is <computeroutput>#TN_CONTEXT_ISR</computeroutput> </para>
</para>

<para>     <emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis></para>

<para><formalpara><title>Returns</title>

<para><computeroutput>TN_TRUE</computeroutput> if current system context is <computeroutput>#TN_CONTEXT_ISR</computeroutput>, <computeroutput>TN_FALSE</computeroutput> otherwise.</para>
</formalpara>
<formalpara><title>See also</title>

<para><computeroutput><link linkend="_tn__sys_8h_1ac3233931746c9d8b84ebd34a2a3a468a">tn_sys_context_get()</link></computeroutput> </para>

<para><computeroutput>enum #<link linkend="_tn__sys_8h_1a54b0c697dfdb3b59e7bcc6eb7badda51">TN_Context</link></computeroutput> </para>
</formalpara>
</para>
<para>
Definition at line 552 of file tn_sys.h.</para>
    </section><anchor xml:id="_tn__sys_8h_1a2ca353dcf362a5aa8d2e5a3960e51410"/>    <section>
    <title>tn_cur_task_get()</title>
<indexterm><primary>tn_cur_task_get</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_cur_task_get</secondary></indexterm>
<para><computeroutput>struct <link linkend="_structTN__Task">TN_Task</link>* tn_cur_task_get (void )</computeroutput></para><para>

<para>Returns pointer to the currently running task. </para>
</para>

<para>    <emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis> </para>
    </section><anchor xml:id="_tn__sys_8h_1afa3c83dce52b17c9ee07b34af0fcebab"/>    <section>
    <title>tn_cur_task_body_get()</title>
<indexterm><primary>tn_cur_task_body_get</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_cur_task_body_get</secondary></indexterm>
<para><computeroutput><link linkend="_tn__common_8h_1a603cbe1ffdafc7e6813ef692bbd7d22f">TN_TaskBody</link>* tn_cur_task_body_get (void )</computeroutput></para><para>

<para>Returns pointer to the body function of the currently running task. </para>
</para>

<para>    <emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis> </para>
    </section><anchor xml:id="_tn__sys_8h_1af1502619506a9c92eb954e45ff0f461b"/>    <section>
    <title>tn_sched_dis_save()</title>
<indexterm><primary>tn_sched_dis_save</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_sched_dis_save</secondary></indexterm>
<para><computeroutput><link linkend="_tn__arch__example_8h_1a39b8c7b5ae653ec71be6f5a821eec3f6">_TN_STATIC_INLINE</link> <link linkend="_tn__arch__example_8h_1ab80cba0fe9ffcd9011d53dfeb9e39bf4">TN_UWord</link> tn_sched_dis_save (void )</computeroutput></para><para>

<para>Disable kernel scheduler and return previous scheduler state. </para>
</para>

<para>Actual behavior depends on the platform:</para>

<para><itemizedlist>
<listitem>
<para>On Microchip platforms, only scheduler&apos;s interrupt gets disabled. All other interrupts are not affected, independently of their priorities.</para>
</listitem><listitem>
<para>On Cortex-M3/M4 platforms, we can only disable interrupts based on priority. So, this function disables all interrupts with lowest priority (since scheduler works at lowest interrupt priority).</para>
</listitem><listitem>
<para>On Cortex-M0/M0+, we have to disable all interrupts.</para>
</listitem></itemizedlist>
</para>

<para>     <emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis></para>

<para><formalpara><title>Returns</title>

<para>State to be restored later by <computeroutput>#<link linkend="_tn__sys_8h_1a4cd5c9113872b2008184c567907653bd">tn_sched_restore()</link></computeroutput> </para>
</formalpara>
</para>
<para>
Definition at line 595 of file tn_sys.h.</para>
    </section><anchor xml:id="_tn__sys_8h_1a4cd5c9113872b2008184c567907653bd"/>    <section>
    <title>tn_sched_restore()</title>
<indexterm><primary>tn_sched_restore</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_sched_restore</secondary></indexterm>
<para><computeroutput><link linkend="_tn__arch__example_8h_1a39b8c7b5ae653ec71be6f5a821eec3f6">_TN_STATIC_INLINE</link> void tn_sched_restore (<link linkend="_tn__arch__example_8h_1ab80cba0fe9ffcd9011d53dfeb9e39bf4">TN_UWord</link> sched_state)</computeroutput></para><para>

<para>Restore state of the kernel scheduler. </para>
</para>

<para>See <computeroutput>#<link linkend="_tn__sys_8h_1af1502619506a9c92eb954e45ff0f461b">tn_sched_dis_save()</link></computeroutput>.</para>

<para>     <emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis></para>

<para>
                <formalpara>
                    <title>
Parameters                    </title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>sched_state</entry>
                                <entry>
<para>Value returned from <computeroutput>#<link linkend="_tn__sys_8h_1af1502619506a9c92eb954e45ff0f461b">tn_sched_dis_save()</link></computeroutput> </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
<para>
Definition at line 611 of file tn_sys.h.</para>
    </section><anchor xml:id="_tn__sys_8h_1ab4e879240635c8f73e20905b8e499c1c"/>    <section>
    <title>tn_callback_dyn_tick_set()</title>
<indexterm><primary>tn_callback_dyn_tick_set</primary><secondary>tn_sys.h</secondary></indexterm>
<indexterm><primary>tn_sys.h</primary><secondary>tn_callback_dyn_tick_set</secondary></indexterm>
<para><computeroutput>void tn_callback_dyn_tick_set (<link linkend="_tn__timer_8h_1a8c64f098ee0fa587a985d149b81bfba9">TN_CBTickSchedule</link> * cb_tick_schedule, <link linkend="_tn__timer_8h_1a4cc3440639e990e3a3015b95e805374a">TN_CBTickCntGet</link> * cb_tick_cnt_get)</computeroutput></para><para>

<para><emphasis>Available if only <link linkend="_tn__cfg__default_8h_1aaee875834a86f961318c584095c366fe"><computeroutput>TN_DYNAMIC_TICK</computeroutput> </link> is <emphasis role="bold">set</emphasis>.</emphasis> </para>
</para>

<para>Set callbacks related to dynamic tick.</para>

<para><caution><title>Attention</title>

<para>This function should be called <emphasis role="bold">before</emphasis> <computeroutput><link linkend="_tn__sys_8h_1a62ab25d9d8ca01c02d368968f19e49bf">tn_sys_start()</link></computeroutput>, otherwise, you&apos;ll run into run-time error <computeroutput>_TN_FATAL_ERROR()</computeroutput>.</para>
</caution>
<emphasis>(refer to <link linkend="_legend">Legend</link> for details)</emphasis></para>

<para>
                <formalpara>
                    <title>
Parameters                    </title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>cb_tick_schedule</entry>
                                <entry>
<para>Pointer to callback function to schedule next time to call <computeroutput><link linkend="_tn__sys_8h_1aa44d297639e0520420890ef2bb7e2c1c">tn_tick_int_processing()</link></computeroutput>, see <computeroutput>#TN_CBTickSchedule</computeroutput> for the prototype. </para>
</entry>
                            </row>
                            <row>
                                <entry>cb_tick_cnt_get</entry>
                                <entry>
<para>Pointer to callback function to get current system tick counter value, see <computeroutput>#TN_CBTickCntGet</computeroutput> for the prototype. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
</section>
</section>
